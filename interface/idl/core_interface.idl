/**
 * module description
 * @module libsbml
 */

enum libsbml__idl__QualifierType_t {
  "libsbml::MODEL_QUALIFIER",
  "libsbml::BIOLOGICAL_QUALIFIER",
  "libsbml::UNKNOWN_QUALIFIER"
};

enum libsbml__idl__BiolQualifierType_t {
  "libsbml::BQB_IS",
  "libsbml::BQB_HAS_PART",
  "libsbml::BQB_IS_PART_OF",
  "libsbml::BQB_IS_VERSION_OF",
  "libsbml::BQB_HAS_VERSION",
  "libsbml::BQB_IS_HOMOLOG_TO",
  "libsbml::BQB_IS_DESCRIBED_BY",
  "libsbml::BQB_IS_ENCODED_BY",
  "libsbml::BQB_ENCODES",
  "libsbml::BQB_OCCURS_IN",
  "libsbml::BQB_HAS_PROPERTY",
  "libsbml::BQB_IS_PROPERTY_OF",
  "libsbml::BQB_HAS_TAXON",
  "libsbml::BQB_UNKNOWN"
};

enum libsbml__idl__ModelQualifierType_t {
  "libsbml::BQM_IS",
  "libsbml::BQM_IS_DESCRIBED_BY",
  "libsbml::BQM_IS_DERIVED_FROM",
  "libsbml::BQM_IS_INSTANCE_OF",
  "libsbml::BQM_HAS_INSTANCE",
  "libsbml::BQM_UNKNOWN"
};

/**
 * A MIRIAM-compliant controlled vocabulary term.
 *
 * The SBML Level 2 and Level 3 specifications define a simple
 * format for annotating models when (a) referring to controlled vocabulary
 * terms and database identifiers that define and describe biological and
 * biochemical entities, and (b) describing the creator of a model and the
 * model's modification history.  This SBML format is a concrete syntax that
 * conforms to the guidelines of MIRIAM (<a target="_blank"
 * href="http://www.nature.com/nbt/journal/v23/n12/abs/nbt1156.html">"Minimum
 * Information Requested in the Annotation of biochemical Models"</a>,
 * <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  The format uses
 * a subset of W3C RDF (<a target="_blank"
 * href="http://www.w3.org/RDF/">Resource Description Format</a>).  In order
 * to help application developers work with annotations in this format,
 * libSBML provides several helper classes that provide higher-level
 * interfaces to the data elements; these classes include CVTerm,
 * ModelCreator, ModelHistory, RDFAnnotationParser, and Date.
 *
 * The parts of a CVTerm
 *
 * Annotations that refer to controlled vocabularies are managed in libSBML
 * using CVTerm objects.  The relation-resource pairs discussed in the
 * previous section are the "controlled vocabulary" terms that CVTerm is
 * designed to store and manipulate.  A set of RDF-based annotations attached
 * to a given SBML `<annotation>` element are read by
 * RDFAnnotationParser and converted into a list of these CVTerm objects.
 * Each CVTerm object instance stores the following components of an
 * annotation:
 *
 * <ul>
 *
 * <li>The qualifier, which can be a BioModels.net "biological
 * qualifier", a BioModels.net "model qualifier", or an unknown qualifier
 * (as far as the CVTerm class is concerned).  Qualifiers are used in
 * MIRIAM to indicate the nature of the relationship between the object
 * being annotated and the resource.  In CVTerm, the qualifiers can be
 * manipulated using the methods CVTerm.getQualifierType(),
 * CVTerm.setQualifierType(), and related methods.
 *
 * <li>The resource, represented by a URI (which, we must remind
 * developers, is not the same as a URL).  In the CVTerm class, the
 * resource component can be manipulated using the methods
 * CVTerm.addResource() and
 * CVTerm.removeResource().
 *
 * </ul>
 *
 * Note that a CVTerm contains a single qualifier, but possibly more than
 * one resource.  This corresponds to the possibility of an annotation that
 * points to multiple resources, all of which are qualified by the same
 * BioModels.net qualifier.  The CVTerm object class supports this by
 * supporting a list of resources.
 *
 * Detailed explanations of the qualifiers defined by BioModels.net can be
 * found at <a target="_blank"
 * href="http://co.mbine.org/standards/qualifiers">http://co.mbine.org/standards/qualifiers</a>.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_c_v_term.html).
 */
[Prefix="libsbml::"]
interface CVTerm {
  /**
   * Adds a resource reference to this CVTerm object.
   *
   * The specific RDF element used in this SBML format for referring to
   * external entities is <rdf:Description>, with a
   * `<rdf:Bag>` element containing one or more
   * `<rdf:li>` elements.  Each such element refers to a
   * data item in an external resource; the resource and data item are
   * together identified uniquely using a URI.
   *
   *
   * ```
   * <rdf:Description rdf:about=&quot;#meta id</span">
   *   HISTORY
   *   <RELATION_ELEMENT>
   *     <rdf:Bag>
   *       <rdf:li rdf:resource=&quot;resource URI</span" />
   *       ...
   *     </rdf:Bag>
   *   </RELATION_ELEMENT>
   *   ...
   * </rdf:Description>
   * ```
   *
   * In the template above, the placeholder `meta id` stands for the
   * element's meta identifier, which is a field available on all SBML
   * components derived from the SBase base object class.  The dotted portions are
   * optional, and the ellipses `...` are placeholders for zero or
   * more elements of the same form as the immediately preceding element.
   * The placeholder
   * `RELATION_ELEMENT` refers to a BioModels.net qualifier element
   * name.  This is an element in either the XML namespace
   * `http://biomodels.net/model-qualifiers` (for model
   * qualifiers) or `http://biomodels.net/biology-qualifiers`
   * (for biological qualifier).
   *
   * The resource `URI` is a required data value that uniquely identifies a
   * resource and data within that resource to which the annotation refers.
   * The present method allows callers to add a reference to a resource URI
   * with the same relationship to the enclosing SBML object.  (In other
   * words, the argument to this method is a `resource URI` as shown in the
   * XML fragment above.)  Resources are stored in this CVTerm object
   * within an XMLAttributes object.
   *
   * The relationship of this CVTerm to the enclosing SBML object can be
   * determined using the CVTerm methods such as
   * CVTerm.getModelQualifierType() and CVTerm.getBiologicalQualifierType().
   *
   * @param {string} resource a string representing the URI of the resource and data
   * item being referenced eg http://www.geneontology.org/#GO:0005892
   */
  long addResource(DOMString resource);
  /**
   * Returns the number of resources for this CVTerm object.
   *
   * The fragment above illustrates that there can be more than one
   * resource referenced by a given relationship annotation (i.e., the
   * resource
   * URI values associated with a particular RELATION_ELEMENT).  The present
   * method returns a count of the resources stored in this CVTerm object.
   *
   * @return {number} the number of resources in the set of XMLAttributes
   * of this CVTerm
   */
  unsigned long getNumResources();
  /**
   * Returns the value of the <em>n</em>th resource for this CVTerm object.
   *
   * The fragment above illustrates that there can be more than one resource
   * referenced by a given relationship annotation (i.e., the resource URI
   * values associated with a particular RELATION_ELEMENT).  LibSBML stores
   * all resource URIs in a single CVTerm object for a given relationship.
   * Callers can use CVTerm::getNumResources() to find out how many resources
   * are stored in this CVTerm object, then call this method to retrieve the
   * <em>n</em>th resource URI.
   *
   * @param {number} n the index of the resource to query.
   *
   * @return string representing the value of the nth resource
   * in the set of XMLAttributes of this CVTerm
   */
	DOMString getResourceURI(unsigned long n);
  /**
   * Removes a resource URI from the set of resources stored in this CVTerm
   * object.
   *
   * @param {string} resource a string representing the resource URI to remove, eg http://www.geneontology.org/#GO:0005892.
   * @see addResource(const std::string& resource)
   */
  long removeResource(DOMString resource);

  libsbml__idl__QualifierType_t getQualifierType();
  long setQualifierType(libsbml__idl__QualifierType_t type);

  libsbml__idl__BiolQualifierType_t getBiologicalQualifierType();
  long setBiologicalQualifierType(libsbml__idl__BiolQualifierType_t type);

  libsbml__idl__ModelQualifierType_t getModelQualifierType();
  long setModelQualifierType(libsbml__idl__ModelQualifierType_t type);
};

/**
 * SBML's  *SBase* class, base class of most SBML objects.
 *
 * Most components in SBML are derived from a single abstract base type,
 * SBase.  In addition to serving as the parent class for most other
 * classes of objects in SBML, this base type is designed to allow a
 * modeler or a software package to attach arbitrary information to each
 * major element or list in an SBML model.
 *
 * SBase has an optional subelement called "notes".  It is intended to
 * serve as a place for storing optional information intended to be seen by
 * humans.  An example use of the "notes" element would be to contain
 * formatted user comments about the model element in which the "notes"
 * element is enclosed.  There are certain conditions on the XHTML content
 * permitted inside the "notes" element; please consult the <a
 * target="_blank" href="http://sbml.org/Documents/Specifications">SBML
 * specification document</a> corresponding to the SBML Level and Version
 * of your model for more information about the requirements for "notes"
 * content.
 *
 * SBase has another optional subelement called "annotation".  Whereas the
 * "notes" element described above is a container for content to be shown
 * directly to humans, the "annotation" element is a container for optional
 * software-generated content *not* meant to be shown to humans.  The
 * element's content type is <a target="_blank"
 * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
 * "any"</a>, allowing essentially arbitrary data content.  SBML places
 * only a few restrictions on the organization of the content; these are
 * intended to help software tools read and write the data as well as help
 * reduce conflicts between annotations added by different tools.  As is
 * the case with "notes", it is important to refer to the <a
 * target="_blank" href="http://sbml.org/Documents/Specifications">SBML
 * specification document</a> corresponding to the SBML Level and Version
 * of your model for more information about the requirements for
 * "annotation" content.
 *
 * It is worth pointing out that the "annotation" element in the definition
 * of SBase exists in order that software developers may attach optional
 * application-specific data to the elements in an SBML model.  However, it
 * is important that this facility not be misused.  In particular, it is
 *  *critical* that data essential to a model definition or that can
 * be encoded in existing SBML elements is  *not* stored in
 * "annotation". Parameter values, functional dependencies between model
 * elements, etc., should not be recorded as annotations.  It is crucial to
 * keep in mind the fact that data placed in annotations can be freely
 * ignored by software applications.  If such data affects the
 * interpretation of a model, then software interoperability is greatly
 * impeded.
 *
 * SBML Level 2 introduced an optional SBase attribute named "metaid" for
 * supporting metadata annotations using RDF (<a target="_blank"
 * href="http://www.w3.org/RDF/">Resource Description Format</a>). The
 * attribute value has the data type <a
 * href="http://www.w3.org/TR/REC-xml/#id">XML ID</a>, the XML identifier
 * type, which means each "metaid" value must be globally unique within an
 * SBML file.  (Importantly, this uniqueness criterion applies across any
 * attribute with type <a href="http://www.w3.org/TR/REC-xml/#id">XML
 * ID</a>, not just the "metaid" attribute used by SBML---something to
 * be aware of if your application-specific XML content inside the
 * "annotation" subelement happens to use <a
 * href="http://www.w3.org/TR/REC-xml/#id">XML ID</a>.)  The "metaid" value
 * serves to identify a model component for purposes such as referencing
 * that component from metadata placed within "annotation" subelements.
 *
 * Beginning with SBML Level 2 Version 2, SBase has an optional
 * attribute named "sboTerm" for supporting the use of the Systems Biology
 * Ontology.  In SBML proper, the data type of the attribute is a string of
 * the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number;
 * libSBML simplifies the representation by only storing the "NNNNNNN"
 * integer portion.  Thus, in libSBML, the "sboTerm" attribute on SBase has
 * data type int, and SBO identifiers are stored simply as integers.
 * (For convenience, SBase offers methods for returning both the integer
 * form and a text-string form of the SBO identifier.)  SBO terms are a
 * type of optional annotation, and each different class of SBML object
 * derived from SBase imposes its own requirements about the values
 * permitted for "sboTerm".  More details can be found in SBML specifications
 * for Level 2 Version 2 and above.
 *
 * Finally, note that, in the list of methods on SBase, there is no public
 * constructor because SBase is an abstract class.  The constructors reside
 * in the subclasses derived from SBase.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_s_base.html).
 */
[Prefix="libsbml::"]
interface SBase {
  /**
   * Returns the value of the "id" attribute of this SBML object, if it has one,
   * or the "variable" attribute of a Rule, or the "symbol" attribute of
   * an InitialAssignment.
   *
   * @return {String} the id of this SBML object, or the "variable" if the object is a
   * Rule, or the "symbol" if the object is an InitialAssignment.
   *
   * @note Because of the inconsistent behavior of this function with respect
   * to assignments and rules, callers should use getIdAttribute() instead.
   */
  DOMString getId();

  /**
   * Sets the value of the "id" attribute of this SBML object.
   *
   * @param {string} id
   */
  boolean setId(DOMString id);

  /**
   * Predicate returning true if this object's "id" attribute is set.
   *
   * @copydetails doc_id_attribute
   *
   * @return {boolean} true if the "id" attribute of this SBML object is
   * set, false otherwise.
   */
  boolean isSetIdAttribute();


  /**
   * Returns the value of the "name" attribute of this SBML object.
   */
  DOMString getName();

  /**
   * Sets the value of the "name" attribute of this SBML object.
   */
  long setName(DOMString name);

  /**
   * Predicate returning true if this
   * object's "name" attribute is set.
   */
  boolean isSetName();

  DOMString getMetaId();
  /**
   * Sets the value of the meta-identifier attribute of this SBML object.
   *
   * The string metaid is copied.
   *
   * @param {string} metaid the identifier string to use as the value of the
   * "metaid" attribute.
   *
   * @see getMetaId()
   * @see isSetMetaId()
   */
  long setMetaId(DOMString metaid);

  /**
   * Predicate returning true if this object's "metaid" attribute is set.
   *
   * @return {boolean} true if the "metaid" attribute of this SBML object is
   * set, false otherwise.
   *
   * @see getMetaId()
   * @see setMetaId(const std::string& metaid)
   */
  boolean isSetMetaId();

  /**
   * Returns the URL representation of the "sboTerm" attribute of this
   * object.
   *
   * This method returns the entire SBO identifier as a text string in the
   * form `http://identifiers.org/biomodels.sbo/SBO:NNNNNNN`.
   *
   * @return {number} the value of the "sboTerm" attribute as an identifiers.org URL,
   * or an empty string if the value is not set.
   */
  long getSBOTerm();
  /**
   * Sets the value of the "sboTerm" attribute.
   *
   * @param {number} value the NNNNNNN integer portion of the SBO identifier
   */
  long setSBOTerm(long value);

  /**
   * Predicate returning true if this
   * object's "sboTerm" attribute is set.
   *
   * @return {boolean} true if the "sboTerm" attribute of this SBML object is
   * set, false otherwise.
   */
  boolean isSetSBOTerm();

  /**
   * Unsets the value of the "sboTerm" attribute of this SBML object.
   */
  long unsetSBOTerm();

  /**
   * Sets the value of the "annotation" subelement of this SBML object.
   *
   * The content of annotation is copied, and any previous content of
   * this object's "annotation" subelement is deleted.
   *
   * Whereas the SBase "notes" subelement is a container for content to be
   * shown directly to humans, the "annotation" element is a container for
   * optional software-generated content not meant to be shown to
   * humans.  Every object derived from SBase can have its own value for
   * "annotation".  The element's content type is <a target="_blank"
   * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
   * "any"</a>, allowing essentially arbitrary well-formed XML data
   * content.
   *
   * SBML places a few restrictions on the organization of the content of
   * annotations; these are intended to help software tools read and write
   * the data as well as help reduce conflicts between annotations added by
   * different tools.  Please see the SBML specifications for more details.
   *
   * Call this method will result in any existing content of the
   * "annotation" subelement to be discarded.  Unless you have taken steps
   * to first copy and reconstitute any existing annotations into the @p
   * annotation that is about to be assigned, it is likely that performing
   * such wholesale replacement is unfriendly towards other software
   * applications whose annotations are discarded.  An alternative may be
   * to use SBase::appendAnnotation(const XMLNode* annotation) or
   * SBase::appendAnnotation(const std::string& annotation).
   *
   * @param annotation an XML string that is to be used as the content
   * of the "annotation" subelement of this object.
   *
   * @see getAnnotationString()
   * @see isSetAnnotation()
   */
  long setAnnotation(DOMString str);

  /**
   * Unsets the value of the "annotation" subelement of this SBML object.
   *
   * Whereas the SBase "notes" subelement is a container for content to be
   * shown directly to humans, the "annotation" element is a container for
   * optional software-generated content not meant to be shown to
   * humans.  Every object derived from SBase can have its own value for
   * "annotation".  The element's content type is <a target="_blank"
   * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
   * "any"</a>, allowing essentially arbitrary well-formed XML data
   * content.
   *
   * SBML places a few restrictions on the organization of the content of
   * annotations; these are intended to help software tools read and write
   * the data as well as help reduce conflicts between annotations added by
   * different tools.  Please see the SBML specifications for more details.
   */
  long unsetAnnotation();

  /**
   * Returns the content of the "annotation" subelement of this object as a
   * character string.
   *
   * The annotations returned by this method will be in string form.  See the
   * method getAnnotation() for a version that returns annotations in XML form.
   *
   * @return {string} the annotation of this SBML object as a character string.
   *
   * @see getAnnotation()
   * @see isSetAnnotation()
   * @see unsetAnnotation()
   */
  DOMString getAnnotationString();

  /**
   * Returns the SBML Level of the SBMLDocument object containing this
   * object.
   *
   * @return {number} the SBML level of this SBML object.
   *
   * @see getVersion()
   */
  unsigned long getLevel();

  /**
   * Returns the Version within the SBML Level of the SBMLDocument object
   * containing this object.
   *
   * @return {number} the SBML version of this SBML object.
   *
   * @see getLevel()
   */
  unsigned long getVersion();

  /**
   * Returns the content of the "notes" subelement of this object as a
   * string.
   *
   * For an alternative method of accessing the notes, see getNotes(),
   * which returns the content as an XMLNode tree structure.  Depending on
   * an application's needs, one or the other method may be more
   * convenient.
   *
   * @return {string} the content of the "notes" subelement of this SBML object as a
   * string.
   *
   * @see getNotes()
   * @see isSetNotes()
   * @see unsetNotes()
   */
  DOMString getNotesString();

  /**
   * Predicate returning true if this
   * object's "notes" subelement exists and has content.
   *
   * The optional SBML element named "notes", present on every major SBML
   * component type, is intended as a place for storing optional
   * information intended to be seen by humans.  An example use of the
   * "notes" element would be to contain formatted user comments about the
   * model element in which the "notes" element is enclosed.  Every object
   * derived directly or indirectly from type SBase can have a separate
   * value for "notes", allowing users considerable freedom when adding
   * comments to their models.
   *
   * The format of "notes" elements must be <a target="_blank"
   * href="http://www.w3.org/TR/xhtml1/">XHTML 1.0</a>.  To help
   * verify the formatting of "notes" content, libSBML provides the static
   * utility method SyntaxChecker::hasExpectedXHTMLSyntax however,
   * readers are urged to consult the appropriate <a target="_blank"
   * href="http://sbml.org/Documents/Specifications">SBML specification
   * document</a> for the Level and Version of their model for more
   * in-depth explanations.  The SBML Level 2 and 3
   * specifications have considerable detail about how "notes" element
   * content must be structured.
   *
   * @return {string} true if a "notes" subelement exists, false otherwise.
   */
  boolean isSetNotes();

  /**
   * Unsets the value of the "notes" subelement of this SBML object.
   *
   * The optional SBML element named "notes", present on every major SBML
   * component type, is intended as a place for storing optional
   * information intended to be seen by humans.  An example use of the
   * "notes" element would be to contain formatted user comments about the
   * model element in which the "notes" element is enclosed.  Every object
   * derived directly or indirectly from type SBase can have a separate
   * value for "notes", allowing users considerable freedom when adding
   * comments to their models.
   *
   * The format of "notes" elements must be <a target="_blank"
   * href="http://www.w3.org/TR/xhtml1/">XHTML 1.0</a>.  To help
   * verify the formatting of "notes" content, libSBML provides the static
   * utility method SyntaxChecker::hasExpectedXHTMLSyntax however,
   * readers are urged to consult the appropriate <a target="_blank"
   * href="http://sbml.org/Documents/Specifications">SBML specification
   * document</a> for the Level and Version of their model for more
   * in-depth explanations.  The SBML Level 2 and 3
   * specifications have considerable detail about how "notes" element
   * content must be structured.
   */
  long unsetNotes();

  /**
   * Returns the number of CVTerm objects in the annotations of this SBML
   * object.
   *
   * @return {number} the number of CVTerms for this SBML object
   */
  long getNumCVTerms();

  /**
   * Returns the nth CVTerm in the list of CVTerms of this SBML
   * object.
   *
   * @param {number} n unsigned int the index of the CVTerm to retrieve
   *
   * @return {CVTerm} the nth CVTerm in the list of CVTerms for this SBML object.
   * If the index n is invalid, NULL is returned.
   */
  CVTerm getCVTerm(unsigned long n);
};

/**
 * A reference to an SBML species in a reaction.
 *
 * The Reaction structure provides a way to express which species act as
 * reactants and which species act as products in a reaction.  In a given
 * reaction, references to those species acting as reactants and/or
 * products are made using instances of SpeciesReference structures in a
 * Reaction object's lists of reactants and products.
 *
 * A species can occur more than once in the lists of reactants and
 * products of a given Reaction instance.  The effective stoichiometry for
 * a species in a reaction is the sum of the stoichiometry values given on
 * the SpeciesReference object in the list of products minus the sum of
 * stoichiometry values given on the SpeciesReference objects in the list
 * of reactants.  A positive value indicates the species is effectively a
 * product and a negative value indicates the species is effectively a
 * reactant.  SBML places no restrictions on the effective stoichiometry of
 * a species in a reaction; for example, it can be zero.
 *
 * In SBML Level 3, the unit of measurement associated with the value of a
 * species' stoichiometry is always considered to be dimensionless.
 * This has the following implications:
 * * When a species reference's identifier appears in mathematical
 * formulas elsewhere in the model, the unit associated with that value is
 * dimensionless.
 *
 * * The units of the "math" elements of AssignmentRule,
 * InitialAssignment and EventAssignment objects setting the stoichiometry
 * of the species reference should be dimensionless.
 *
 * * If a species reference's identifier is the subject of a RateRule,
 * the unit associated with the RateRule object's value should be
 * dimensionless/<em>time</em>, where <em>time</em> is the
 * model-wide unit of time set on the Model object.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_species_reference.html)
 */
[Prefix="libsbml::"]
interface SpeciesReference {
  DOMString getSpecies();
  long setSpecies(DOMString spec);
  boolean isSetSpecies();

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();
};

SpeciesReference implements SBase;

[Prefix="libsbml::"]
interface ModifierSpeciesReference {
  DOMString getSpecies();
  long setSpecies(DOMString spec);
  boolean isSetSpecies();
};

ModifierSpeciesReference implements SBase;

[Prefix="libsbml::"]
interface Species {
  double getInitialAmount();
  long setInitialAmount(double amt);
  boolean isSetInitialAmount();

  double getInitialConcentration();
  long setInitialConcentration(double conc);
  boolean isSetInitialConcentration();

  boolean getHasOnlySubstanceUnits();
  long setHasOnlySubstanceUnits(boolean val);
  boolean isSetHasOnlySubstanceUnits();

  // TODO: doc
  DOMString getCompartment();
  long setCompartment(DOMString comp);
  boolean isSetCompartment();

  // TODO: doc
  DOMString getUnits();
  long setUnits(DOMString units);
  boolean isSetUnits();

  boolean getBoundaryCondition();
  long setBoundaryCondition(boolean value);
  boolean isSetBoundaryCondition();

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();

  DOMString getSubstanceUnits();
  long setSubstanceUnits(DOMString sid);
  boolean isSetSubstanceUnits();

  DOMString getConversionFactor();
  long setConversionFactor(DOMString sid);
  boolean isSetConversionFactor();
};

Species implements SBase;

[Prefix="libsbml::"]
interface Unit {
  long getScale();

  boolean isAmpere();
  boolean isAvogadro();
  boolean isBecquerel();
  boolean isCandela();
  boolean isCelsius();
  boolean isCoulomb();
  boolean isDimensionless();
  boolean isFarad();
  boolean isGram();
  boolean isGray();
  boolean isHenry();
  boolean isHertz();
  boolean isItem();
  boolean isJoule();
  boolean isKatal();
  boolean isKelvin();
  boolean isKilogram();
  boolean isLitre();
  boolean isLumen();
  boolean isLux();
  boolean isMetre();
  boolean isMole();
  boolean isNewton();
  boolean isOhm();
  boolean isPascal();
  boolean isRadian();
  boolean isSecond();
  boolean isSiemens();
  boolean isSievert();
  boolean isSteradian();
  boolean isTesla();
  boolean isVolt();
  boolean isWatt();
  boolean isWeber();
};

Unit implements SBase;

[Prefix="libsbml::"]
interface UnitDefinition {
  unsigned long getNumUnits();
  Unit createUnit();
  Unit getUnit(unsigned long n);
};

UnitDefinition implements SBase;

enum libsbml__idl__ASTNodeType_t {
    "libsbml::AST_PLUS"
  , "libsbml::AST_MINUS"
  , "libsbml::AST_TIMES"
  , "libsbml::AST_DIVIDE"
  , "libsbml::AST_POWER"

  , "libsbml::AST_INTEGER"
  , "libsbml::AST_REAL"
  , "libsbml::AST_REAL_E"
  , "libsbml::AST_RATIONAL"

  , "libsbml::AST_NAME"
  , "libsbml::AST_NAME_AVOGADRO"
  , "libsbml::AST_NAME_TIME"

  , "libsbml::AST_CONSTANT_E"
  , "libsbml::AST_CONSTANT_FALSE"
  , "libsbml::AST_CONSTANT_PI"
  , "libsbml::AST_CONSTANT_TRUE"

  , "libsbml::AST_LAMBDA"

  , "libsbml::AST_FUNCTION"
  , "libsbml::AST_FUNCTION_ABS"
  , "libsbml::AST_FUNCTION_ARCCOS"
  , "libsbml::AST_FUNCTION_ARCCOSH"
  , "libsbml::AST_FUNCTION_ARCCOT"
  , "libsbml::AST_FUNCTION_ARCCOTH"
  , "libsbml::AST_FUNCTION_ARCCSC"
  , "libsbml::AST_FUNCTION_ARCCSCH"
  , "libsbml::AST_FUNCTION_ARCSEC"
  , "libsbml::AST_FUNCTION_ARCSECH"
  , "libsbml::AST_FUNCTION_ARCSIN"
  , "libsbml::AST_FUNCTION_ARCSINH"
  , "libsbml::AST_FUNCTION_ARCTAN"
  , "libsbml::AST_FUNCTION_ARCTANH"
  , "libsbml::AST_FUNCTION_CEILING"
  , "libsbml::AST_FUNCTION_COS"
  , "libsbml::AST_FUNCTION_COSH"
  , "libsbml::AST_FUNCTION_COT"
  , "libsbml::AST_FUNCTION_COTH"
  , "libsbml::AST_FUNCTION_CSC"
  , "libsbml::AST_FUNCTION_CSCH"
  , "libsbml::AST_FUNCTION_DELAY"
  , "libsbml::AST_FUNCTION_EXP"
  , "libsbml::AST_FUNCTION_FACTORIAL"
  , "libsbml::AST_FUNCTION_FLOOR"
  , "libsbml::AST_FUNCTION_LN"
  , "libsbml::AST_FUNCTION_LOG"
  , "libsbml::AST_FUNCTION_PIECEWISE"
  , "libsbml::AST_FUNCTION_POWER"
  , "libsbml::AST_FUNCTION_ROOT"
  , "libsbml::AST_FUNCTION_SEC"
  , "libsbml::AST_FUNCTION_SECH"
  , "libsbml::AST_FUNCTION_SIN"
  , "libsbml::AST_FUNCTION_SINH"
  , "libsbml::AST_FUNCTION_TAN"
  , "libsbml::AST_FUNCTION_TANH"

  , "libsbml::AST_LOGICAL_AND"
  , "libsbml::AST_LOGICAL_NOT"
  , "libsbml::AST_LOGICAL_OR"
  , "libsbml::AST_LOGICAL_XOR"

  , "libsbml::AST_RELATIONAL_EQ"
  , "libsbml::AST_RELATIONAL_GEQ"
  , "libsbml::AST_RELATIONAL_GT"
  , "libsbml::AST_RELATIONAL_LEQ"
  , "libsbml::AST_RELATIONAL_LT"
  , "libsbml::AST_RELATIONAL_NEQ"

  /*, "libsbml::AST_QUALIFIER_BVAR"
  , "libsbml::AST_QUALIFIER_LOGBASE"
  , "libsbml::AST_QUALIFIER_DEGREE"

  , "libsbml::AST_SEMANTICS"

  , "libsbml::AST_CONSTRUCTOR_PIECE"
  , "libsbml::AST_CONSTRUCTOR_OTHERWISE"*/

  /*, "libsbml::AST_UNKNOWN"
  , "libsbml::AST_ORIGINATES_IN_PACKAGE"*/
  // TODO: add min/max based on libsbml version
};

[Prefix="libsbml::"]
interface ASTNode {
  long getNumChildren();
  ASTNode getChild(long i);

  libsbml__idl__ASTNodeType_t getType();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  ByteString getName();
  long setName(ByteString name);
};

[Prefix="libsbml::"]
interface Parameter {
  double getValue();
  long setValue(double value);
  boolean isSetValue();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();
};

Parameter implements SBase;

[Prefix="libsbml::"]
interface Delay {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface Priority {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface EventAssignment {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] DOMString getVariable();
    long setVariable(DOMString variable);
    boolean isSetVariable();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface Trigger {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();

    boolean getPersistent();
    long setPersistent(boolean persistent);
    boolean isSetPersistent();
};

[Prefix="libsbml::"]
interface Event {
  DOMString getId();
  boolean setId(DOMString id);

  DOMString getName();
  long setName(DOMString name);
  boolean isSetName();

  Delay createDelay();
  Delay getDelay();
  long setDelay([Const] Delay delay);
  boolean isSetDelay();

  Priority createPriority();
  long setPriority(Priority priority);
  Priority getPriority();
  boolean isSetPriority();

  long setTrigger(Trigger trigger);
  Trigger getTrigger();
  boolean isSetTrigger();

  EventAssignment createEventAssignment();
  EventAssignment getEventAssignment(unsigned long n);
  unsigned long getNumEventAssignments();
};

[Prefix="libsbml::"]
interface FunctionDefinition {
  DOMString getId();
  boolean setId(DOMString id);

  DOMString getName();
  long setName(DOMString name);
  boolean isSetName();

  unsigned long getNumArguments();
  [Const] ASTNode getArgument(unsigned long n);

  [Const] ASTNode getBody();
  boolean isSetBody();

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();
};

[Prefix="libsbml::"]
interface LocalParameter {
  double getValue();
  long setValue(double value);
  boolean isSetValue();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();
};

LocalParameter implements SBase;

[Prefix="libsbml::"]
interface KineticLaw {
  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  unsigned long getNumLocalParameters();
  LocalParameter createLocalParameter();
  LocalParameter getLocalParameter(unsigned long i);

  unsigned long getNumParameters();
  Parameter createParameter();
  Parameter getParameter(unsigned long i);

  DOMString getFormula();
  long setFormula(DOMString formula);
};

KineticLaw implements SBase;

[Prefix="libsbml::"]
interface SBMLFormulaParser {
  void SBMLFormulaParser();
  ASTNode parseL3Formula(DOMString formula);
  ASTNode parseFormula(DOMString formula);
};

[Prefix="libsbml::"]
interface Reaction {
  long getNumReactants();
  long getNumProducts();
  long getNumModifiers();

  SpeciesReference getReactant(long i);
  SpeciesReference getProduct(long i);
  ModifierSpeciesReference getModifier(long i);

  long addReactant(SpeciesReference sr);
  long addProduct(SpeciesReference sr);
  long addModifier(ModifierSpeciesReference sr);

  SpeciesReference createReactant();
  SpeciesReference createProduct();
  ModifierSpeciesReference createModifier();

  KineticLaw createKineticLaw();
  KineticLaw getKineticLaw();
  boolean isSetKineticLaw();

  boolean getReversible();
  long setReversible(boolean value);
  boolean isSetReversible();
};

Reaction implements SBase;

[Prefix="libsbml::"]
interface Compartment {
  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();

  double getSize();
  long setSize(double val);
  boolean isSetSize();

  double getVolume();
  long setVolume(double val);
  boolean isSetVolume();

  DOMString getUnits();
  long setUnits(DOMString units);
  boolean isSetUnits();
};

Compartment implements SBase;

[Prefix="libsbml::"]
interface Rule {
  boolean isRate();
  boolean isAssignment();
  boolean isAlgebraic();

  DOMString getFormula();
  long setFormula(DOMString formula);

  boolean isParameter();
};

Rule implements SBase;

[Prefix="libsbml::"]
interface AssignmentRule {
  DOMString getVariable();
  long setVariable(DOMString id);
  boolean isSetVariable();

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  DOMString getFormula();
  long setFormula(DOMString formula);

  boolean isParameter();
};

AssignmentRule implements SBase;

[Prefix="libsbml::"]
interface RateRule {
  DOMString getFormula();
  long setFormula(DOMString formula);

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  boolean isParameter();
};

RateRule implements SBase;

[Prefix="libsbml::"]
interface AlgebraicRule {
  DOMString getFormula();
  long setFormula(DOMString formula);

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  boolean isParameter();
};

AlgebraicRule implements SBase;

[Prefix="libsbmljs::"]
interface RuleSwitch {
  void RuleSwitch();

  AssignmentRule castToAssignmentRule(Rule r);
  RateRule castToRateRule(Rule r);
  AlgebraicRule castToAlgebraicRule(Rule r);
};

[Prefix="libsbml::"]
interface Model {
  unsigned long getNumReactions();
  Reaction getReaction(unsigned long i);
  Reaction createReaction();

  unsigned long getNumSpecies();
  Species createSpecies();
  Species getSpecies(unsigned long i);
  Species removeSpecies(unsigned long i);

  unsigned long getNumUnitDefinitions();
  UnitDefinition getUnitDefinition(unsigned long i);
  UnitDefinition createUnitDefinition();

  unsigned long getNumCompartments();
  Compartment getCompartment(unsigned long i);
  Compartment createCompartment();

  unsigned long getNumParameters();
  Parameter createParameter();
  Parameter getParameter(unsigned long i);

  unsigned long getNumEvents();
  Event createEvent();
  Event getEvent(unsigned long i);

  unsigned long getNumFunctionDefinitions();
  FunctionDefinition createFunctionDefinition();
  FunctionDefinition getFunctionDefinition(unsigned long i);

  unsigned long getNumRules();
  Rule getRule(unsigned long i);

  unsigned long getNumPlugins();
  SBasePlugin getPlugin(unsigned long n);
//   SBasePlugin getPlugin(DOMString name);
};

Model implements SBase;

[Prefix="libsbml::"]
interface SBMLError {
  DOMString getMessage();
};

[Prefix="libsbml::"]
interface SBMLErrorLog {
// reserved word apparently. whoop-de-doo
//   DOMString toString();
};

[Prefix="libsbml::"]
interface SBasePlugin {
  // TODO: doc
  DOMString getPackageName();

  // TODO: doc
  DOMString getPrefix();

  // TODO: doc
  DOMString getURI();
  unsigned long getVersion();
  unsigned long getLevel();
};

enum libsbml__idl__SBMLErrorCategory_t {
  "libsbml::LIBSBML_CAT_SBML",
  "libsbml::LIBSBML_CAT_SBML_L1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L2V1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L2V2_COMPAT",
  "libsbml::LIBSBML_CAT_GENERAL_CONSISTENCY",
  "libsbml::LIBSBML_CAT_IDENTIFIER_CONSISTENCY",
  "libsbml::LIBSBML_CAT_UNITS_CONSISTENCY",
  "libsbml::LIBSBML_CAT_MATHML_CONSISTENCY",
  "libsbml::LIBSBML_CAT_SBO_CONSISTENCY",
  "libsbml::LIBSBML_CAT_OVERDETERMINED_MODEL",
  "libsbml::LIBSBML_CAT_SBML_L2V3_COMPAT",
  "libsbml::LIBSBML_CAT_MODELING_PRACTICE",
  "libsbml::LIBSBML_CAT_INTERNAL_CONSISTENCY",
  "libsbml::LIBSBML_CAT_SBML_L2V4_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L3V1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L3V2_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_COMPATIBILITY"
};

[Prefix="libsbml::"]
interface SBMLDocument {
  // ctor
  void SBMLDocument(long level, long version);

  // model
  Model getModel();
  Model createModel();

  // errors
  unsigned long getNumErrors();
  [Const] SBMLError getError(unsigned long n);
  SBMLErrorLog getErrorLog();

  // level / version
  unsigned long getVersion();
  unsigned long getLevel();

  // plugins / packages
  unsigned long getNumPlugins();
  SBasePlugin getPlugin(unsigned long n);

  boolean enablePackage(DOMString pkgName, DOMString pkgPrefix, boolean flag);
  boolean disablePackage(DOMString pkgName, DOMString pkgPrefix);
  boolean isPackageEnabled(DOMString pkgName);
  long setPackageRequired(DOMString pkgName, boolean flag);

  // validation
  unsigned long checkConsistency();
  unsigned long checkInternalConsistency();
  unsigned long validateSBML();

  // compatibility checking
  unsigned long checkL1Compatibility();
  unsigned long checkL2v1Compatibility();
  unsigned long checkL2v2Compatibility();
  unsigned long checkL2v3Compatibility();
  unsigned long checkL2v4Compatibility();
  unsigned long checkL3v1Compatibility();
  unsigned long checkL3v2Compatibility();

  void setConsistencyChecks(libsbml__idl__SBMLErrorCategory_t category, boolean apply);
};

[Prefix="libsbml::"]
interface SBMLReader {
  void SBMLReader();
  SBMLDocument readSBMLFromString(DOMString sbmlstr);
};

// different name req'd b/c libsbml version did not have consistent usage of types
[Prefix="libsbml::"]
interface SBMLWriter {
  void SBMLWriter();
  // BUG in Emscripten: memory may not be freed
  ByteString writeSBMLToString(SBMLDocument doc);
};

[Prefix="libsbmljs::"]
interface Capabilities {
  void Capabilities();
  boolean isLayoutSupported();
  boolean isRenderSupported();
};
