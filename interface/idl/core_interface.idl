/**
 * module description
 * @module libsbml
 */

enum libsbml__idl__QualifierType_t {
  "libsbml::MODEL_QUALIFIER",
  "libsbml::BIOLOGICAL_QUALIFIER",
  "libsbml::UNKNOWN_QUALIFIER"
};

enum libsbml__idl__BiolQualifierType_t {
  "libsbml::BQB_IS",
  "libsbml::BQB_HAS_PART",
  "libsbml::BQB_IS_PART_OF",
  "libsbml::BQB_IS_VERSION_OF",
  "libsbml::BQB_HAS_VERSION",
  "libsbml::BQB_IS_HOMOLOG_TO",
  "libsbml::BQB_IS_DESCRIBED_BY",
  "libsbml::BQB_IS_ENCODED_BY",
  "libsbml::BQB_ENCODES",
  "libsbml::BQB_OCCURS_IN",
  "libsbml::BQB_HAS_PROPERTY",
  "libsbml::BQB_IS_PROPERTY_OF",
  "libsbml::BQB_HAS_TAXON",
  "libsbml::BQB_UNKNOWN"
};

enum libsbml__idl__ModelQualifierType_t {
  "libsbml::BQM_IS",
  "libsbml::BQM_IS_DESCRIBED_BY",
  "libsbml::BQM_IS_DERIVED_FROM",
  "libsbml::BQM_IS_INSTANCE_OF",
  "libsbml::BQM_HAS_INSTANCE",
  "libsbml::BQM_UNKNOWN"
};

/**
 * # A MIRIAM-compliant controlled vocabulary term.
 *
 * The SBML Level 2 and Level 3 specifications define a simple
 * format for annotating models when (a) referring to controlled vocabulary
 * terms and database identifiers that define and describe biological and
 * biochemical entities, and (b) describing the creator of a model and the
 * model's modification history.  This SBML format is a concrete syntax that
 * conforms to the guidelines of MIRIAM (<a target="_blank"
 * href="http://www.nature.com/nbt/journal/v23/n12/abs/nbt1156.html">"Minimum
 * Information Requested in the Annotation of biochemical Models"</a>,
 * <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  The format uses
 * a subset of W3C RDF (<a target="_blank"
 * href="http://www.w3.org/RDF/">Resource Description Format</a>).  In order
 * to help application developers work with annotations in this format,
 * libSBML provides several helper classes that provide higher-level
 * interfaces to the data elements; these classes include CVTerm,
 * ModelCreator, ModelHistory, RDFAnnotationParser, and Date.
 *
 * # The parts of a CVTerm
 *
 * Annotations that refer to controlled vocabularies are managed in libSBML
 * using CVTerm objects.  The relation-resource pairs discussed in the
 * previous section are the "controlled vocabulary" terms that CVTerm is
 * designed to store and manipulate.  A set of RDF-based annotations attached
 * to a given SBML `<annotation>` element are read by
 * RDFAnnotationParser and converted into a list of these CVTerm objects.
 * Each CVTerm object instance stores the following components of an
 * annotation:
 *
 *
 * * The qualifier, which can be a BioModels.net "biological
 * qualifier", a BioModels.net "model qualifier", or an unknown qualifier
 * (as far as the CVTerm class is concerned).  Qualifiers are used in
 * MIRIAM to indicate the nature of the relationship between the object
 * being annotated and the resource.  In CVTerm, the qualifiers can be
 * manipulated using the methods CVTerm.getQualifierType(),
 * CVTerm.setQualifierType(), and related methods.
 *
 * * The resource, represented by a URI (which, we must remind
 * developers, is not the same as a URL).  In the CVTerm class, the
 * resource component can be manipulated using the methods
 * CVTerm.addResource() and
 * CVTerm.removeResource().
 *
 *
 * Note that a CVTerm contains a single qualifier, but possibly more than
 * one resource.  This corresponds to the possibility of an annotation that
 * points to multiple resources, all of which are qualified by the same
 * BioModels.net qualifier.  The CVTerm object class supports this by
 * supporting a list of resources.
 *
 * Detailed explanations of the qualifiers defined by BioModels.net can be
 * found at <a target="_blank"
 * href="http://co.mbine.org/standards/qualifiers">http://co.mbine.org/standards/qualifiers</a>.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_c_v_term.html).
 */
[Prefix="libsbml::"]
interface CVTerm {
  /**
   * Adds a resource reference to this CVTerm object.
   *
   * The specific RDF element used in this SBML format for referring to
   * external entities is <rdf:Description>, with a
   * `<rdf:Bag>` element containing one or more
   * `<rdf:li>` elements.  Each such element refers to a
   * data item in an external resource; the resource and data item are
   * together identified uniquely using a URI.
   *
   *
   * ```
   * <rdf:Description rdf:about=&quot;#meta id</span">
   *   HISTORY
   *   <RELATION_ELEMENT>
   *     <rdf:Bag>
   *       <rdf:li rdf:resource=&quot;resource URI</span" />
   *       ...
   *     </rdf:Bag>
   *   </RELATION_ELEMENT>
   *   ...
   * </rdf:Description>
   * ```
   *
   * In the template above, the placeholder `meta id` stands for the
   * element's meta identifier, which is a field available on all SBML
   * components derived from the SBase base object class.  The dotted portions are
   * optional, and the ellipses `...` are placeholders for zero or
   * more elements of the same form as the immediately preceding element.
   * The placeholder
   * `RELATION_ELEMENT` refers to a BioModels.net qualifier element
   * name.  This is an element in either the XML namespace
   * `http://biomodels.net/model-qualifiers` (for model
   * qualifiers) or `http://biomodels.net/biology-qualifiers`
   * (for biological qualifier).
   *
   * The resource `URI` is a required data value that uniquely identifies a
   * resource and data within that resource to which the annotation refers.
   * The present method allows callers to add a reference to a resource URI
   * with the same relationship to the enclosing SBML object.  (In other
   * words, the argument to this method is a `resource URI` as shown in the
   * XML fragment above.)  Resources are stored in this CVTerm object
   * within an XMLAttributes object.
   *
   * The relationship of this CVTerm to the enclosing SBML object can be
   * determined using the CVTerm methods such as
   * CVTerm.getModelQualifierType() and CVTerm.getBiologicalQualifierType().
   *
   * @param {string} resource a string representing the URI of the resource and data
   * item being referenced eg http://www.geneontology.org/#GO:0005892
   */
  long addResource(DOMString resource);
  /**
   * Returns the number of resources for this CVTerm object.
   *
   * The fragment above illustrates that there can be more than one
   * resource referenced by a given relationship annotation (i.e., the
   * resource
   * URI values associated with a particular RELATION_ELEMENT).  The present
   * method returns a count of the resources stored in this CVTerm object.
   *
   * @return {number} the number of resources in the set of XMLAttributes
   * of this CVTerm
   */
  unsigned long getNumResources();
  /**
   * Returns the value of the nth resource for this CVTerm object.
   *
   * The fragment above illustrates that there can be more than one resource
   * referenced by a given relationship annotation (i.e., the resource URI
   * values associated with a particular RELATION_ELEMENT).  LibSBML stores
   * all resource URIs in a single CVTerm object for a given relationship.
   * Callers can use CVTerm.getNumResources() to find out how many resources
   * are stored in this CVTerm object, then call this method to retrieve the
   * nth resource URI.
   *
   * @param {number} n the index of the resource to query.
   *
   * @return string representing the value of the nth resource
   * in the set of XMLAttributes of this CVTerm
   */
	DOMString getResourceURI(unsigned long n);
  /**
   * Removes a resource URI from the set of resources stored in this CVTerm
   * object.
   *
   * @param {string} resource a string representing the resource URI to remove, eg http://www.geneontology.org/#GO:0005892.
   * @see addResource(const std::string& resource)
   */
  long removeResource(DOMString resource);

  /**
   * Returns the qualifier type of this CVTerm object.
   *
   * The placeholder
   * RELATION_ELEMENT refers to a BioModels.net qualifier
   * element name.  This is an element in either the XML namespace
   * `http://biomodels.net/model-qualifiers` (for model
   * qualifiers) or `http://biomodels.net/biology-qualifiers`
   * (for biological qualifier).  The present method returns a code
   * identifying which one of these two relationship namespaces is being
   * used; any other qualifier in libSBML is considered unknown (as far as
   * the CVTerm class is concerned).  Consequently, this method will return
   * one of the following values:
   *
   * ```
   * libsbml.MODEL_QUALIFIER
   * libsbml.BIOLOGICAL_QUALIFIER
   * libsbml.UNKNOWN_QUALIFIER
   * ```
   *
   * The specific relationship of this CVTerm to the enclosing SBML object
   * can be determined using the CVTerm methods such as
   * CVTerm.getModelQualifierType() and
   * CVTerm.getBiologicalQualifierType().  Callers will typically want to
   * use the present method to find out which one of the other two
   * methods to call to find out the specific relationship.
   *
   * @return {QualifierType_t} the qualifier type
   * of this object or `libsbml.UNKNOWN_QUALIFIER`
   * (the default).
   *
   * @see getResources()
   * @see getModelQualifierType()
   * @see getBiologicalQualifierType()
   */
  libsbml__idl__QualifierType_t getQualifierType();

  /**
   * Sets the qualifier code of this
   * CVTerm object.
   *
   * @param {QualifierType_t} type the qualifier type
   *
   * @see getQualifierType()
   */
  long setQualifierType(libsbml__idl__QualifierType_t type);

  /**
   * Returns the biological qualifier type of this CVTerm object.
   *
   * The placeholder
   * RELATION_ELEMENT refers to a BioModels.net qualifier element
   * name.  This is an element in either the XML namespace
   * `http://biomodels.net/model-qualifiers` (for model
   * qualifiers) or `http://biomodels.net/biology-qualifiers`
   * (for biological qualifier).  Callers will typically use
   * CVTerm::getQualifierType() to find out the type of qualifier relevant to
   * this particular CVTerm object, then if it is a biological qualifier,
   * use the present method to determine the specific qualifier.
   *
   * Annotations with biological qualifiers express a relationship between an
   * annotation resource and the biological concept represented by a
   * given object in the model. The diagram
   * below illustrates the relationship in this case:
   *
   * The set of known biological qualifiers is, at the time of this
   * libSBML release, the following:
   *
   * ```
   * libsbml.BQB_IS
   * libsbml.BQB_HAS_PART
   * libsbml.BQB_IS_PART_OF
   * libsbml.BQB_IS_VERSION_OF
   * libsbml.BQB_HAS_VERSION
   * libsbml.BQB_IS_HOMOLOG_TO
   * libsbml.BQB_IS_DESCRIBED_BY
   * libsbml.BQB_IS_ENCODED_BY
   * libsbml.BQB_ENCODES
   * libsbml.BQB_OCCURS_IN
   * libsbml.BQB_HAS_PROPERTY
   * libsbml.BQB_IS_PROPERTY_OF
   * libsbml.BQB_HAS_TAXON
   * ```
   *
   * Any other BioModels.net qualifier found in the model is considered
   * unknown by libSBML and reported as
   * libsbml.BQB_UNKNOWN.
   *
   * @return {BiolQualifierType_t} the biology qualifier type
   * of this object or `libsbml.BQB_UNKNOWN`
   * (the default).
   */
  libsbml__idl__BiolQualifierType_t getBiologicalQualifierType();

  /**
   * Sets the biology qualifier
   * type of this CVTerm object.
   *
   * @param {BiolQualifierType_t} type the biology
   * qualifier type.
   *
   * **Note:** If the Qualifier Type of this object is not
   * libsbml.BIOLOGICAL_QUALIFIER,
   * then the biology qualifier type
   * will default to libsbml.BQB_UNKNOWN.
   *
   * @see getQualifierType()
   */
  long setBiologicalQualifierType(libsbml__idl__BiolQualifierType_t type);

  /**
   * Returns the model qualifier type of this CVTerm object.
   *
   * The placeholder
   * RELATION_ELEMENT refers to a BioModels.net qualifier
   * element name.  This is an element in either the XML namespace
   * `http://biomodels.net/model-qualifiers` (for model
   * qualifiers) or `http://biomodels.net/biology-qualifiers`
   * (for biological qualifier).  Callers will typically use
   * CVTerm::getQualifierType() to find out the type of qualifier relevant to this
   * particular CVTerm object, then if it is a model qualifier, use the
   * present method to determine the specific qualifier.
   *
   * Annotations with model qualifiers express a relationship between an
   * annotation resource and the modeling concept represented by a
   * given object in the model.  The diagram below illustrates the
   * relationship in this case:
   *
   * @image html model-qualifiers.png "Relationship expressed by model qualifiers"
   * @image latex model-qualifiers.png "Relationship expressed by model qualifiers"
   *
   * The set of known model qualifiers is, at the time of this libSBML
   * release, the following:
   *
   * ```
   * libsbml.BQM_IS
   * libsbml.BQM_IS_DESCRIBED_BY
   * libsbml.BQM_IS_DERIVED_FROM
   * libsbml.BQM_IS_INSTANCE_OF
   * libsbml.BQM_HAS_INSTANCE
   * ```
   *
   * Any other BioModels.net qualifier found in the model is considered
   * unknown by libSBML and reported as
   * libsbml.BQM_UNKNOWN.
   *
   * @return {ModelQualifierType_t} the model qualifier
   * of this object or libsbml.BQM_UNKNOWN
   * (the default).
   */
  libsbml__idl__ModelQualifierType_t getModelQualifierType();

  /**
   * Sets the model qualifier type
   * of this CVTerm object.
   *
   * @param {ModelQualifierType_t} type the model qualifier type.
   *
   * **Note:** If the qualifier type of this object is not
   * libsbml.MODEL_QUALIFIER, then the
   * then the model qualifier typ
   * will default to libsbml.BQM_UNKNOWN.
   *
   * @see getQualifierType()
   */
  long setModelQualifierType(libsbml__idl__ModelQualifierType_t type);
};

/**
 * # SBML's  SBase class, base class of most SBML objects.
 *
 * Most components in SBML are derived from a single abstract base type,
 * SBase.  In addition to serving as the parent class for most other
 * classes of objects in SBML, this base type is designed to allow a
 * modeler or a software package to attach arbitrary information to each
 * major element or list in an SBML model.
 *
 * SBase has an optional subelement called "notes".  It is intended to
 * serve as a place for storing optional information intended to be seen by
 * humans.  An example use of the "notes" element would be to contain
 * formatted user comments about the model element in which the "notes"
 * element is enclosed.  There are certain conditions on the XHTML content
 * permitted inside the "notes" element; please consult the <a
 * target="_blank" href="http://sbml.org/Documents/Specifications">SBML
 * specification document</a> corresponding to the SBML Level and Version
 * of your model for more information about the requirements for "notes"
 * content.
 *
 * SBase has another optional subelement called "annotation".  Whereas the
 * "notes" element described above is a container for content to be shown
 * directly to humans, the "annotation" element is a container for optional
 * software-generated content *not* meant to be shown to humans.  The
 * element's content type is <a target="_blank"
 * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
 * "any"</a>, allowing essentially arbitrary data content.  SBML places
 * only a few restrictions on the organization of the content; these are
 * intended to help software tools read and write the data as well as help
 * reduce conflicts between annotations added by different tools.  As is
 * the case with "notes", it is important to refer to the <a
 * target="_blank" href="http://sbml.org/Documents/Specifications">SBML
 * specification document</a> corresponding to the SBML Level and Version
 * of your model for more information about the requirements for
 * "annotation" content.
 *
 * It is worth pointing out that the "annotation" element in the definition
 * of SBase exists in order that software developers may attach optional
 * application-specific data to the elements in an SBML model.  However, it
 * is important that this facility not be misused.  In particular, it is
 *  *critical* that data essential to a model definition or that can
 * be encoded in existing SBML elements is  *not* stored in
 * "annotation". Parameter values, functional dependencies between model
 * elements, etc., should not be recorded as annotations.  It is crucial to
 * keep in mind the fact that data placed in annotations can be freely
 * ignored by software applications.  If such data affects the
 * interpretation of a model, then software interoperability is greatly
 * impeded.
 *
 * SBML Level 2 introduced an optional SBase attribute named "metaid" for
 * supporting metadata annotations using RDF (<a target="_blank"
 * href="http://www.w3.org/RDF/">Resource Description Format</a>). The
 * attribute value has the data type <a
 * href="http://www.w3.org/TR/REC-xml/#id">XML ID</a>, the XML identifier
 * type, which means each "metaid" value must be globally unique within an
 * SBML file.  (Importantly, this uniqueness criterion applies across any
 * attribute with type <a href="http://www.w3.org/TR/REC-xml/#id">XML
 * ID</a>, not just the "metaid" attribute used by SBML---something to
 * be aware of if your application-specific XML content inside the
 * "annotation" subelement happens to use <a
 * href="http://www.w3.org/TR/REC-xml/#id">XML ID</a>.)  The "metaid" value
 * serves to identify a model component for purposes such as referencing
 * that component from metadata placed within "annotation" subelements.
 *
 * Beginning with SBML Level 2 Version 2, SBase has an optional
 * attribute named "sboTerm" for supporting the use of the Systems Biology
 * Ontology.  In SBML proper, the data type of the attribute is a string of
 * the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number;
 * libSBML simplifies the representation by only storing the "NNNNNNN"
 * integer portion.  Thus, in libSBML, the "sboTerm" attribute on SBase has
 * data type int, and SBO identifiers are stored simply as integers.
 * (For convenience, SBase offers methods for returning both the integer
 * form and a text-string form of the SBO identifier.)  SBO terms are a
 * type of optional annotation, and each different class of SBML object
 * derived from SBase imposes its own requirements about the values
 * permitted for "sboTerm".  More details can be found in SBML specifications
 * for Level 2 Version 2 and above.
 *
 * Finally, note that, in the list of methods on SBase, there is no public
 * constructor because SBase is an abstract class.  The constructors reside
 * in the subclasses derived from SBase.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_s_base.html).
 */
[Prefix="libsbml::"]
interface SBase {
  /**
   * Returns the value of the "id" attribute of this SBML object, if it has one,
   * or the "variable" attribute of a Rule, or the "symbol" attribute of
   * an InitialAssignment.
   *
   * @return {String} the id of this SBML object, or the "variable" if the object is a
   * Rule, or the "symbol" if the object is an InitialAssignment.
   *
   * **Note:** Because of the inconsistent behavior of this function with respect
   * to assignments and rules, callers should use getIdAttribute() instead.
   */
  DOMString getId();

  /**
   * Sets the value of the "id" attribute of this SBML object.
   *
   * @param {string} id
   */
  boolean setId(DOMString id);

  /**
   * Predicate returning true if this object's "id" attribute is set.
   *
   * @return {boolean} true if the "id" attribute of this SBML object is
   * set, false otherwise.
   */
  boolean isSetIdAttribute();


  /**
   * Returns the value of the "name" attribute of this SBML object.
   */
  DOMString getName();

  /**
   * Sets the value of the "name" attribute of this SBML object.
   */
  long setName(DOMString name);

  /**
   * Predicate returning true if this
   * object's "name" attribute is set.
   */
  boolean isSetName();

  DOMString getMetaId();
  /**
   * Sets the value of the meta-identifier attribute of this SBML object.
   *
   * The string metaid is copied.
   *
   * @param {string} metaid the identifier string to use as the value of the
   * "metaid" attribute.
   *
   * @see getMetaId()
   * @see isSetMetaId()
   */
  long setMetaId(DOMString metaid);

  /**
   * Predicate returning true if this object's "metaid" attribute is set.
   *
   * @return {boolean} true if the "metaid" attribute of this SBML object is
   * set, false otherwise.
   *
   * @see getMetaId()
   * @see setMetaId(const std::string& metaid)
   */
  boolean isSetMetaId();

  /**
   * Returns the URL representation of the "sboTerm" attribute of this
   * object.
   *
   * This method returns the entire SBO identifier as a text string in the
   * form `http://identifiers.org/biomodels.sbo/SBO:NNNNNNN`.
   *
   * @return {number} the value of the "sboTerm" attribute as an identifiers.org URL,
   * or an empty string if the value is not set.
   */
  long getSBOTerm();
  /**
   * Sets the value of the "sboTerm" attribute.
   *
   * @param {number} value the NNNNNNN integer portion of the SBO identifier
   */
  long setSBOTerm(long value);

  /**
   * Predicate returning true if this
   * object's "sboTerm" attribute is set.
   *
   * @return {boolean} true if the "sboTerm" attribute of this SBML object is
   * set, false otherwise.
   */
  boolean isSetSBOTerm();

  /**
   * Unsets the value of the "sboTerm" attribute of this SBML object.
   */
  long unsetSBOTerm();

  /**
   * Sets the value of the "annotation" subelement of this SBML object.
   *
   * The content of annotation is copied, and any previous content of
   * this object's "annotation" subelement is deleted.
   *
   * Whereas the SBase "notes" subelement is a container for content to be
   * shown directly to humans, the "annotation" element is a container for
   * optional software-generated content not meant to be shown to
   * humans.  Every object derived from SBase can have its own value for
   * "annotation".  The element's content type is <a target="_blank"
   * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
   * "any"</a>, allowing essentially arbitrary well-formed XML data
   * content.
   *
   * SBML places a few restrictions on the organization of the content of
   * annotations; these are intended to help software tools read and write
   * the data as well as help reduce conflicts between annotations added by
   * different tools.  Please see the SBML specifications for more details.
   *
   * Call this method will result in any existing content of the
   * "annotation" subelement to be discarded.  Unless you have taken steps
   * to first copy and reconstitute any existing annotations into the @p
   * annotation that is about to be assigned, it is likely that performing
   * such wholesale replacement is unfriendly towards other software
   * applications whose annotations are discarded.  An alternative may be
   * to use SBase::appendAnnotation(const XMLNode* annotation) or
   * SBase::appendAnnotation(const std::string& annotation).
   *
   * @param annotation an XML string that is to be used as the content
   * of the "annotation" subelement of this object.
   *
   * @see getAnnotationString()
   * @see isSetAnnotation()
   */
  long setAnnotation(DOMString str);

  /**
   * Unsets the value of the "annotation" subelement of this SBML object.
   *
   * Whereas the SBase "notes" subelement is a container for content to be
   * shown directly to humans, the "annotation" element is a container for
   * optional software-generated content not meant to be shown to
   * humans.  Every object derived from SBase can have its own value for
   * "annotation".  The element's content type is <a target="_blank"
   * href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls">XML type
   * "any"</a>, allowing essentially arbitrary well-formed XML data
   * content.
   *
   * SBML places a few restrictions on the organization of the content of
   * annotations; these are intended to help software tools read and write
   * the data as well as help reduce conflicts between annotations added by
   * different tools.  Please see the SBML specifications for more details.
   */
  long unsetAnnotation();

  /**
   * Returns the content of the "annotation" subelement of this object as a
   * character string.
   *
   * The annotations returned by this method will be in string form.  See the
   * method getAnnotation() for a version that returns annotations in XML form.
   *
   * @return {string} the annotation of this SBML object as a character string.
   *
   * @see getAnnotation()
   * @see isSetAnnotation()
   * @see unsetAnnotation()
   */
  DOMString getAnnotationString();

  /**
   * Returns the SBML Level of the SBMLDocument object containing this
   * object.
   *
   * @return {number} the SBML level of this SBML object.
   *
   * @see getVersion()
   */
  unsigned long getLevel();

  /**
   * Returns the Version within the SBML Level of the SBMLDocument object
   * containing this object.
   *
   * @return {number} the SBML version of this SBML object.
   *
   * @see getLevel()
   */
  unsigned long getVersion();

  /**
   * Returns the content of the "notes" subelement of this object as a
   * string.
   *
   * For an alternative method of accessing the notes, see getNotes(),
   * which returns the content as an XMLNode tree structure.  Depending on
   * an application's needs, one or the other method may be more
   * convenient.
   *
   * @return {string} the content of the "notes" subelement of this SBML object as a
   * string.
   *
   * @see getNotes()
   * @see isSetNotes()
   * @see unsetNotes()
   */
  DOMString getNotesString();

  /**
   * Predicate returning true if this
   * object's "notes" subelement exists and has content.
   *
   * The optional SBML element named "notes", present on every major SBML
   * component type, is intended as a place for storing optional
   * information intended to be seen by humans.  An example use of the
   * "notes" element would be to contain formatted user comments about the
   * model element in which the "notes" element is enclosed.  Every object
   * derived directly or indirectly from type SBase can have a separate
   * value for "notes", allowing users considerable freedom when adding
   * comments to their models.
   *
   * The format of "notes" elements must be <a target="_blank"
   * href="http://www.w3.org/TR/xhtml1/">XHTML 1.0</a>.  To help
   * verify the formatting of "notes" content, libSBML provides the static
   * utility method SyntaxChecker::hasExpectedXHTMLSyntax however,
   * readers are urged to consult the appropriate <a target="_blank"
   * href="http://sbml.org/Documents/Specifications">SBML specification
   * document</a> for the Level and Version of their model for more
   * in-depth explanations.  The SBML Level 2 and 3
   * specifications have considerable detail about how "notes" element
   * content must be structured.
   *
   * @return {string} true if a "notes" subelement exists, false otherwise.
   */
  boolean isSetNotes();

  /**
   * Unsets the value of the "notes" subelement of this SBML object.
   *
   * The optional SBML element named "notes", present on every major SBML
   * component type, is intended as a place for storing optional
   * information intended to be seen by humans.  An example use of the
   * "notes" element would be to contain formatted user comments about the
   * model element in which the "notes" element is enclosed.  Every object
   * derived directly or indirectly from type SBase can have a separate
   * value for "notes", allowing users considerable freedom when adding
   * comments to their models.
   *
   * The format of "notes" elements must be <a target="_blank"
   * href="http://www.w3.org/TR/xhtml1/">XHTML 1.0</a>.  To help
   * verify the formatting of "notes" content, libSBML provides the static
   * utility method SyntaxChecker::hasExpectedXHTMLSyntax however,
   * readers are urged to consult the appropriate <a target="_blank"
   * href="http://sbml.org/Documents/Specifications">SBML specification
   * document</a> for the Level and Version of their model for more
   * in-depth explanations.  The SBML Level 2 and 3
   * specifications have considerable detail about how "notes" element
   * content must be structured.
   */
  long unsetNotes();

  /**
   * Returns the number of CVTerm objects in the annotations of this SBML
   * object.
   *
   * @return {number} the number of CVTerms for this SBML object
   */
  long getNumCVTerms();

  /**
   * Returns the nth CVTerm in the list of CVTerms of this SBML
   * object.
   *
   * @param {number} n unsigned int the index of the CVTerm to retrieve
   *
   * @return {CVTerm} the nth CVTerm in the list of CVTerms for this SBML object.
   * If the index n is invalid, NULL is returned.
   */
  CVTerm getCVTerm(unsigned long n);
};

/**
 * # A reference to an SBML species in a reaction.
 *
 * The Reaction structure provides a way to express which species act as
 * reactants and which species act as products in a reaction.  In a given
 * reaction, references to those species acting as reactants and/or
 * products are made using instances of SpeciesReference structures in a
 * Reaction object's lists of reactants and products.
 *
 * A species can occur more than once in the lists of reactants and
 * products of a given Reaction instance.  The effective stoichiometry for
 * a species in a reaction is the sum of the stoichiometry values given on
 * the SpeciesReference object in the list of products minus the sum of
 * stoichiometry values given on the SpeciesReference objects in the list
 * of reactants.  A positive value indicates the species is effectively a
 * product and a negative value indicates the species is effectively a
 * reactant.  SBML places no restrictions on the effective stoichiometry of
 * a species in a reaction; for example, it can be zero.
 *
 * In SBML Level 3, the unit of measurement associated with the value of a
 * species' stoichiometry is always considered to be dimensionless.
 * This has the following implications:
 * * When a species reference's identifier appears in mathematical
 * formulas elsewhere in the model, the unit associated with that value is
 * dimensionless.
 *
 * * The units of the "math" elements of AssignmentRule,
 * InitialAssignment and EventAssignment objects setting the stoichiometry
 * of the species reference should be dimensionless.
 *
 * * If a species reference's identifier is the subject of a RateRule,
 * the unit associated with the RateRule object's value should be
 * dimensionless/time, where time is the
 * model-wide unit of time set on the Model object.
 *
 * See the [libSBML C++ docs for this class](http://sbml.org/Software/libSBML/5.17.0/docs//cpp-api/class_species_reference.html)
 */
[Prefix="libsbml::"]
interface SpeciesReference {
  /**
   * Get the value of the "species" attribute.
   *
   * @return {string} the value of the attribute "species" for this
   * SpeciesReference
   */
  DOMString getSpecies();

  /**
   * Predicate returning true if this
   * SpeciesReference's "species" attribute is set.
   *
   * @return {boolean} true if the "species" attribute of this
   * SpeciesReference is set, false otherwise.
   */
  long setSpecies(DOMString spec);
  /**
   * Predicate returning true if this
   * SpeciesReference's "species" attribute is set.
   *
   * @return {boolean} true if the "species" attribute of this
   * SpeciesReference is set, false otherwise.
   */
  boolean isSetSpecies();

  /**
   * Get the value of the "constant" attribute.
   *
   * @return {boolean} the value of the "constant" attribute of this
   * SpeciesReference.
   */
  boolean getConstant();

  /**
   * Sets the "constant" attribute of this SpeciesReference to the given boolean
   * flag.
   *
   * @param {boolean} flag, the value for the "constant" attribute of this
   * SpeciesReference instance.
   */
  long setConstant(boolean value);

  /**
   * Predicate returning true if this
   * SpeciesReference's "constant" attribute is set
   *
   * @return {boolean} true if the "constant" attribute of this
   * SpeciesReference is set, false otherwise.
   */
  boolean isSetConstant();
};

SpeciesReference implements SBase;

/**
 * # A reference to an SBML modifier species.
 *
 * Sometimes a species appears in the kinetic rate formula of a reaction
 * but is itself neither created nor destroyed in that reaction (for
 * example, because it acts as a catalyst or inhibitor).  In SBML, all such
 * species are simply called modifiers without regard to the detailed
 * role of those species in the model.  The Reaction structure provides a
 * way to express which species act as modifiers in a given reaction.  This
 * is the purpose of the list of modifiers available in Reaction.  The list
 * contains instances of ModifierSpeciesReference structures.
 *
 * The ModifierSpeciesReference structure inherits the mandatory attribute
 * "species" and optional attributes "id" and "name" from the parent class
 * SimpleSpeciesReference.  See the description of SimpleSpeciesReference
 * for more information about these.
 *
 * The value of the "species" attribute must be the identifier of a species
 * defined in the enclosing Model; this species is designated as a modifier
 * for the current reaction.  A reaction may have any number of modifiers.
 * It is permissible for a modifier species to appear simultaneously in the
 * list of reactants and products of the same reaction where it is
 * designated as a modifier, as well as to appear in the list of reactants,
 * products and modifiers of other reactions in the model.
 */
[Prefix="libsbml::"]
interface ModifierSpeciesReference {
  /**
   * Get the value of the "species" attribute.
   *
   * @return {string} the value of the attribute "species" for this
   * SpeciesReference
   */
  DOMString getSpecies();

  /**
   * Predicate returning true if this
   * SpeciesReference's "species" attribute is set.
   *
   * @return {boolean} true if the "species" attribute of this
   * SpeciesReference is set, false otherwise.
   */
  long setSpecies(DOMString spec);

  /**
   * Predicate returning true if this
   * SpeciesReference's "species" attribute is set.
   *
   * @return {boolean} true if the "species" attribute of this
   * SpeciesReference is set, false otherwise.
   */
  boolean isSetSpecies();
};

ModifierSpeciesReference implements SBase;

/**
 * # An SBML species - a pool of entities.
 *
 * A species in SBML refers to a pool of entities that (a) are
 * considered indistinguishable from each other for the purposes of the
 * model, (b) participate in reactions, and (c) are located in a specific
 * compartment.  The SBML Species object class is intended to represent
 * these pools.
 *
 * As with other major constructs in SBML, Species has a mandatory
 * attribute, "id", used to give the species type an identifier in the
 * model.  The identifier must be a text string conforming to the identifer
 * syntax permitted in SBML.  Species also has an optional "name"
 * attribute, of type string.  The "id" and "name" must be used
 * according to the guidelines described in the SBML specifications.
 *
 * The required attribute "compartment" is used to identify the compartment
 * in which the species is located.  The attribute's value must be the
 * identifier of an existing Compartment object.  It is important to note
 * that there is no default value for the "compartment" attribute on
 * Species; every species in an SBML model must be assigned a compartment
 * explicitly.  (This also implies that every model with one or more
 * Species objects must define at least one Compartment object.)
 *
 *
 * @section species-amounts The initial amount and concentration of a species
 *
 * The optional attributes "initialAmount" and "initialConcentration", both
 * having a data type of double, can be used to set the initial
 * quantity of the species in the compartment where the species is located.
 * These attributes are mutually exclusive; i.e., only one can
 * have a value on any given instance of a Species object.  Missing
 * "initialAmount" and "initialConcentration" values implies that their
 * values either are unknown, or to be obtained from an external source, or
 * determined by an InitialAssignment or other SBML construct elsewhere in
 * the model.
 *
 * A species' initial quantity in SBML is set by the "initialAmount" or
 * "initialConcentration" attribute exactly once.  If the "constant"
 * attribute is true, then the value of the species' quantity is fixed
 * and cannot be changed except by an InitialAssignment.  These methods
 * differ in that the "initialAmount" and "initialConcentration" attributes
 * can only be used to set the species quantity to a literal floating-point
 * number, whereas the use of an InitialAssignment object allows the value
 * to be set using an arbitrary mathematical expression (which, thanks to
 * MathML's expressiveness, may evaluate to a rational number).  If the
 * species' "constant" attribute is false, the species' quantity value
 * may be overridden by an InitialAssignment or changed by AssignmentRule
 * or AlgebraicRule, and in addition, for t > 0, it may also be
 * changed by a RateRule, Event objects, and as a result of being a
 * reactant or product in one or more Reaction objects.  (However, some
 * constructs are mutually exclusive; see the SBML specifications for the
 * precise details.)  It is not an error to define "initialAmount" or
 * "initialConcentration" on a species and also redefine the value using an
 * InitialAssignment, but the "initialAmount" or "initialConcentration"
 * setting in that case is ignored.  The SBML specifications provide
 * additional information about the semantics of assignments, rules and
 * values for simulation time t < 0.
 *
 * SBML Level 2 additionally stipulates that in cases where a species'
 * compartment has a "spatialDimensions" value of 0 (zero), the species
 * cannot have a value for "initialConcentration" because the concepts of
 * concentration and density break down when a container has zero
 * dimensions.
 *
 * @section species-units The units of a species' amount or concentration
 *
 * When the attribute "initialAmount" is set, the unit of measurement
 * associated with the value of "initialAmount" is specified by the Species
 * attribute "substanceUnits".  When the "initialConcentration" attribute
 * is set, the unit of measurement associated with this concentration value
 * is {unit of amount} divided by {unit of size}, where
 * the {unit of amount} is specified by the Species
 * "substanceUnits" attribute, and the {unit of size} is specified
 * by the "units" attribute of the Compartment object in which the species
 * is located.  Note that in either case, a unit of amount is
 * involved and determined by the "substanceUnits" attribute.  Note
 *  these two attributes alone do not determine the units of the
 * species when the species identifier appears in a mathematical
 * expression ; that aspect is determined by the attribute
 * "hasOnlySubstanceUnits" discussed below.
 *
 * In SBML Level 3, if the "substanceUnits" attribute is not set on a
 * given Species object instance, then the unit of amount for that
 * species is inherited from the "substanceUnits" attribute on the
 * enclosing Model object instance.  If that attribute on Model is not set
 * either, then the unit associated with the species' quantity is
 * undefined.
 *
 * In SBML Level 2, if the "substanceUnits" attribute is not set on a
 * given Species object instance, then the unit of amount for that
 * species is taken from the predefined SBML unit identifier
 * "substance".  The value assigned to "substanceUnits" must be chosen from
 * one of the following possibilities: one of the base unit identifiers
 * defined in SBML, the built-in unit identifier "substance", or the
 * identifier of a new unit defined in the list of unit definitions in the
 * enclosing Model object.  The chosen units for "substanceUnits" must be
 * be "dimensionless", "mole", "item", "kilogram", "gram",
 * or units derived from these.
 *
 * As noted at the beginning of this section, simply setting
 * "initialAmount" or "initialConcentration" alone does not determine
 * whether a species identifier represents an amount or a concentration
 * when it appears elsewhere in an SBML model.  The role of the attribute
 * "hasOnlySubstanceUnits" is to indicate whether the units of the species,
 * when the species identifier appears in mathematical formulas, are
 * intended to be concentration or amount.  The attribute takes on a
 * boolean value.  In SBML Level 3, the attribute has no default value
 * and must always be set in a model; in SBML Level 2, it has a
 * default value of false.
 *
 * The units of the species are used in the following ways:
 *
 * * When the species' identifier appears in a MathML formula, it
 * represents the species' quantity, and the unit of measurement associated
 * with the quantity is as described above.
 *
 * * The "math" elements of AssignmentRule, InitialAssignment and
 * EventAssignment objects referring to this species should all have the
 * same units as the unit of measurement associated with the species
 * quantity.
 *
 * * In a RateRule object that defines the rate of change of the
 * species' quantity, the unit associated with the rule's "math" element
 * should be equal to the unit of the species' quantity divided by the
 * model-wide unit of time; in other words, {unit of species
 * quantity}/{unit of time}.
 *
 *
 * # The "constant" and "boundaryCondition" attributes
 *
 * The Species object class has two boolean attributes named "constant" and
 * "boundaryCondition", used to indicate whether and how the quantity of
 * that species can vary during a simulation.  In SBML Level 2 they
 * are optional; in SBML Level 3 they are mandatory.  The following
 * table shows how to interpret the combined values of these attributes.
 *
 * By default, when a species is a product or reactant of one or more
 * reactions, its quantity is determined by those reactions.  In SBML, it
 * is possible to indicate that a given species' quantity is not
 * determined by the set of reactions even when that species occurs as a
 * product or reactant; i.e., the species is on the boundary of
 * the reaction system, and its quantity is not determined by the
 * reactions.  The boolean attribute "boundaryCondition" can be used to
 * indicate this.  A value of false indicates that the species is
 * part of the reaction system.  In SBML Level 2, the attribute has a
 * default value of false, while in SBML Level 3, it has no
 * default.
 *
 * The "constant" attribute indicates whether the species' quantity can be
 * changed at all, regardless of whether by reactions, rules, or constructs
 * other than InitialAssignment.  A value of false indicates that the
 * species' quantity can be changed.  (This is also a common value because
 * the purpose of most simulations is precisely to calculate changes in
 * species quantities.)  In SBML Level 2, the attribute has a default
 * value of false, while in SBML Level 3, it has no default.  Note
 * that the initial quantity of a species can be set by an
 * InitialAssignment irrespective of the value of the "constant" attribute.
 *
 * In practice, a "boundaryCondition" value of true means a differential
 * equation derived from the reaction definitions should not be generated
 * for the species.  However, the species' quantity may still be changed by
 * AssignmentRule, RateRule, AlgebraicRule, Event, and InitialAssignment
 * constructs if its "constant" attribute is false.  Conversely, if the
 * species' "constant" attribute is true, then its value cannot be
 * changed by anything except InitialAssignment.
 *
 * A species having "boundaryCondition"=false and "constant"=false
 * can appear as a product and/or reactant of one or more reactions in the
 * model.  If the species is a reactant or product of a reaction, it must
 * not also appear as the target of any AssignmentRule or RateRule
 * object in the model.  If instead the species has "boundaryCondition"=
 * false and "constant"=true, then it cannot appear as a reactant or
 * product, or as the target of any AssignmentRule, RateRule or
 * EventAssignment object in the model.
 *
 * Finally, it is worth clarifying that while the constant and
 * boundaryCondition attributes restrict whether and how the species
 * amount changes, the same is not true of a species' concentration. In
 * SBML, the concentration of a species is a quantity that depends on the
 * size of the compartment in which it is located. A compartment's size
 * may change, and therefore, so can the concentration of a species even
 * if the amount of the species remains unchanged. A species' concentration
 * may therefore vary even if the Species object's constant attribute is
 * set to true in a model.
 *
 * # The conversionFactor attribute in SBML Level 3
 *
 * In SBML Level 3, Species has an additional optional attribute,
 * "conversionFactor", that defines a conversion factor that applies to a
 * particular species.  The value must be the identifier of a Parameter
 * object instance defined in the model.  That Parameter object must be a
 * constant, meaning its "constant" attribute must be set to true.
 * If a given Species object definition defines a value for its
 * "conversionFactor" attribute, it takes precedence over any factor
 * defined by the Model object's "conversionFactor" attribute.
 *
 * The unit of measurement associated with a species' quantity can be
 * different from the unit of extent of reactions in the model.  SBML
 * Level 3 avoids implicit unit conversions by providing an explicit
 * way to indicate any unit conversion that might be required.  The use of
 * a conversion factor in computing the effects of reactions on a species'
 * quantity is explained in detail in the SBML Level 3 specification
 * document.  Because the value of the "conversionFactor" attribute is the
 * identifier of a Parameter object, and because parameters can have units
 * attached to them, the transformation from reaction extent units to
 * species units can be completely specified using this approach.
 *
 * Note that the unit conversion factor is  only applied when
 * calculating the effect of a reaction on a species .  It is not
 * used in any rules or other SBML constructs that affect the species, and
 * it is also not used when the value of the species is referenced in a
 * mathematical expression.
 *
 *
 * # The speciesType attribute in SBML Level 2 Versions 2-4
 *
 * In SBML Level 2 Versions 2-4, each species in a model
 * may optionally be designated as belonging to a particular species type.
 * The optional attribute "speciesType" is used to identify the species
 * type of the chemical entities that make up the pool represented by the
 * Species objects.  The attribute's value must be the identifier of an
 * existing SpeciesType object in the model.  If the "speciesType"
 * attribute is not present on a particular species definition, it means
 * the pool contains chemical entities of a type unique to that pool; in
 * effect, a virtual species type is assumed for that species, and no other
 * species can belong to that species type.  The value of "speciesType"
 * attributes on species have no effect on the numerical interpretation of
 * a model; simulators and other numerical analysis software may ignore
 * "speciesType" attributes.
 *
 * There can be only one species of a given species type in any given
 * compartment of a model.  More specifically, for all Species objects
 * having a value for the "speciesType" attribute, the pair
 * ("speciesType" attribute value, "compartment" attribute value)
 *
 *
 * must be unique across the set of all Species object in a model.
 *
 *
 * # The spatialSizeUnits attribute in SBML Level 2 Versions 1-2
 *
 * In versions of SBML Level 2 before Version 3, the class
 * Species included an attribute called "spatialSizeUnits", which allowed
 * explicitly setting the units of size for initial concentration.  LibSBML
 * retains this attribute for compatibility with older definitions of
 * Level 2, but its use is strongly discouraged because many software
 * tools do no properly interpret this unit declaration and it is
 * incompatible with all SBML specifications after Level 2
 * Version 3.
 *
 *
 * @section species-math Additional considerations for interpreting the numerical value of a species
 *
 * Species are unique in SBML in that they have a kind of duality: a
 * species identifier may stand for either substance amount (meaning, a
 * count of the number of individual entities) or a concentration or
 * density (meaning, amount divided by a compartment size).  The previous
 * sections explain the meaning of a species identifier when it is
 * referenced in a mathematical formula or in rules or other SBML
 * constructs; however, it remains to specify what happens to a species
 * when the compartment in which it is located changes in size.
 *
 * When a species definition has a "hasOnlySubstanceUnits" attribute value
 * of false and the size of the compartment in which the species is
 * located changes, the default in SBML is to assume that it is the
 * concentration that must be updated to account for the size change.  This
 * follows from the principle that, all other things held constant, if a
 * compartment simply changes in size, the size change does not in itself
 * cause an increase or decrease in the number of entities of any species
 * in that compartment.  In a sense, the default is that the amount of
 * a species is preserved across compartment size changes.  Upon such size
 * changes, the value of the concentration or density must be recalculated
 * from the simple relationship concentration = amount / size if
 * the value of the concentration is needed (for example, if the species
 * identifier appears in a mathematical formula or is otherwise referenced
 * in an SBML construct).  There is one exception: if the species' quantity
 * is determined by an AssignmentRule, RateRule, AlgebraicRule, or an
 * EventAssignment and the species has a "hasOnlySubstanceUnits" attribute
 * value of false, it means that the concentration is assigned
 * by the rule or event; in that case, the amount must be
 * calculated when the compartment size changes.  (Events also require
 * additional care in this situation, because an event with multiple
 * assignments could conceivably reassign both a species quantity and a
 * compartment size simultaneously.  Please refer to the SBML
 * specifications for the details.)
 *
 * Note that the above only matters if a species has a
 * "hasOnlySubstanceUnits" attribute value of false, meaning that the
 * species identifier refers to a concentration wherever the identifier
 * appears in a mathematical formula.  If instead the attribute's value is
 * true, then the identifier of the species always stands for
 * an amount wherever it appears in a mathematical formula or is referenced
 * by an SBML construct.  In that case, there is never a question about
 * whether an assignment or event is meant to affect the amount or
 * concentration: it is always the amount.
 *
 * A particularly confusing situation can occur when the species has
 * "constant" attribute value of true in combination with a
 * "hasOnlySubstanceUnits" attribute value of false.  Suppose this
 * species is given a value for "initialConcentration".  Does a "constant"
 * value of true mean that the concentration is held constant if the
 * compartment size changes?  No; it is still the amount that is kept
 * constant across a compartment size change.  The fact that the species
 * was initialized using a concentration value is irrelevant.
 */
[Prefix="libsbml::"]
interface Species {
  /**
   * Get the value of the "initialAmount" attribute.
   *
   * @return {number} the initialAmount of this Species, as a floating point number
   */
  double getInitialAmount();

  /**
   * Sets the "initialAmount" attribute of this Species and marks the field
   * as set.
   *
   * This method also unsets the "initialConcentration" attribute.
   *
   * @param {number} value the value to which the "initialAmount" attribute should
   * be set
   */
  long setInitialAmount(double value);

  /**
   * Predicate returning true if this
   * Species object's "initialAmount" attribute is set.
   *
   * @return {boolean} true if the "initialAmount" attribute of this Species is
   * set, false otherwise
   *
   * **Note:** In SBML Level 1, Species' "initialAmount" is required and
   * therefore <em>should always be set</em>.  (However, in Level 1, the
   * attribute has no default value either, so this method will not return
   * true until a value has been assigned.)  In SBML Level 2,
   * "initialAmount" is optional and as such may or may not be set.
   */
  boolean isSetInitialAmount();

  /**
   * Get the value of the "initialConcentration" attribute.
   *
   * @return {number} the initialConcentration of this Species, as a floating point
   * number
   *
   * **Note:** The attribute "initialConcentration" is only available in SBML
   * Level 2 and 3.  It does not exist on Species in Level 1.
   */
  double getInitialConcentration();

  /**
   * Sets the "initialConcentration" attribute of this Species and marks
   * the field as set.
   *
   * This method also unsets the "initialAmount" attribute.
   *
   * @param {number} value the value to which the "initialConcentration" attribute
   * should be set
   *
   * **Note:** The attribute "initialConcentration" is only available in SBML
   * Level 2 and 3.  It does not exist on Species in Level 1.
   */
  long setInitialConcentration(double value);

  /**
   * Predicate returning true if this
   * Species object's "initialConcentration" attribute is set.
   *
   * @return {boolean} true if the "initialConcentration" attribute of this Species is
   * set, false otherwise
   *
   * **Note:** The attribute "initialConcentration" is only available in SBML
   * Level 2 and 3.  It does not exist on Species in Level 1.
   */
  boolean isSetInitialConcentration();

  /**
   * Get the value of the "hasOnlySubstanceUnits" attribute.
   *
   * @return {boolean} true if this Species' "hasOnlySubstanceUnits" attribute
   * value is true, false otherwise
   *
   * **Note:** The "hasOnlySubstanceUnits" attribute does not exist in SBML
   * Level 1.
   */
  boolean getHasOnlySubstanceUnits();

  /**
   * Sets the "hasOnlySubstanceUnits" attribute of this Species object.
   *
   * @param {boolean} value boolean value for the "hasOnlySubstanceUnits" attribute
   *
   * **Note:** The "hasOnlySubstanceUnits" attribute does not exist in SBML
   * Level 1.
   */
  long setHasOnlySubstanceUnits(boolean value);

  /**
   * Predicate returning true if this
   * Species object's "hasOnlySubstanceUnits" attribute is set.
   *
   * @return {boolean} true if the "hasOnlySubstanceUnits" attribute of this Species is
   * set, false otherwise
   *
   * **Note:** The "hasOnlySubstanceUnits" attribute does not exist in SBML
   * Level 1.
   */
  boolean isSetHasOnlySubstanceUnits();

  /**
   * Get the compartment in which this species is located.
   *
   * The compartment is designated by its identifier.
   *
   * @return {string} the value of the "compartment" attribute of this Species
   * object, as a string.
   */
  DOMString getCompartment();

  /**
   * Sets the "compartment" attribute of this Species object.
   *
   * @param {string} sid the identifier of a Compartment object defined elsewhere
   * in this Model
   */
  long setCompartment(DOMString comp);

  /**
   * Predicate returning true if this
   * Species object's "compartment" attribute is set.
   *
   * @return {boolean} true if the "compartment" attribute of this Species is
   * set, false otherwise.
   */
  boolean isSetCompartment();

  /**
   * Get the value of the "units" attribute.
   *
   * @return {string} the units of this Species (L1 only)
   */
  DOMString getUnits();

  /**
   * (SBML Level 1 only) Sets the units of this Species object.
   *
   * @param {string} sname the identifier of the unit to use.
  */
  long setUnits(DOMString units);

  /**
   * Predicate returning true if
   * this Species object's "units" attribute is set.
   *
   * @return {boolean} true if the "units" attribute of this Species is
   * set, false otherwise
   */
  boolean isSetUnits();

  /**
   * Get the value of the "boundaryCondition" attribute.
   *
   * @return {boolean} true if this Species' "boundaryCondition" attribute value
   * is true, false otherwise
   */
  boolean getBoundaryCondition();
  long setBoundaryCondition(boolean value);

  /**
   * Predicate returning true if this
   * Species object's "boundaryCondition" attribute is set.
   *
   * @return {boolean} true if the "boundaryCondition" attribute of this Species is
   * set, false otherwise
   */
  boolean isSetBoundaryCondition();

  /**
   * Get the value of the "constant" attribute.
   *
   * @return {boolean} true if this Species's "constant" attribute value is
   * true, false otherwise
   *
   * **Note:** The attribute "constant" is only available in SBML Levels 2
   * and 3.  It does not exist on Species in Level 1.
   */
  boolean getConstant();

  /**
   * Sets the "constant" attribute of this Species object.
   *
   * @param {value} value a boolean value for the "constant" attribute
   *
   * **Note:** The attribute "constant" is only available in SBML Levels 2
   * and 3.  It does not exist on Species in Level 1.
   */
  long setConstant(boolean value);

  /**
   * Predicate returning true if this
   * Species object's "constant" attribute is set.
   *
   * @return {boolean} true if the "constant" attribute of this Species is
   * set, false otherwise
   *
   * **Note:** The attribute "constant" is only available in SBML Levels 2
   * and 3.  It does not exist on Species in Level 1.
   */
  boolean isSetConstant();

  /**
   * Get the value of the "substanceUnits" attribute.
   *
   * @return {string} the value of the "substanceUnits" attribute of this Species,
   * as a string.  An empty string indicates that no units have been
   * assigned
   *
   * @see isSetSubstanceUnits()
   * @see setSubstanceUnits()
   */
  DOMString getSubstanceUnits();

  /**
   * Sets the "substanceUnits" attribute of this Species object.
   *
   * @param {string} sid the identifier of the unit to use
   */
  long setSubstanceUnits(DOMString sid);

  /**
   * Predicate returning true if this
   * Species object's "substanceUnits" attribute is set.
   *
   * @return {boolean} true if the "substanceUnits" attribute of this Species is
   * set, false otherwise
   */
  boolean isSetSubstanceUnits();

  /**
   * Get the value of the "conversionFactor" attribute.
   *
   * @return {string} the conversionFactor of this Species, as a string
   *
   * **Note:** The "conversionFactor" attribute was introduced in SBML
   * Level 3.  It does not exist on Species in SBML Levels 1
   * and 2.
   */
  DOMString getConversionFactor();

  /**
   * Sets the value of the "conversionFactor" attribute of this Species object.
   *
   * The string in sid is copied.
   *
   * @param {string} sid the new conversionFactor for the Species
   *
   * **Note:** The "conversionFactor" attribute was introduced in SBML
   * Level 3.  It does not exist on Species in SBML Levels 1
   * and 2.
   */
  long setConversionFactor(DOMString sid);

  /**
   * Predicate returning true if this
   * Species object's "conversionFactor" attribute is set.
   *
   * @return {boolean} true if the "conversionFactor" attribute of this Species is
   * set, false otherwise
   *
   * **Note:** The "conversionFactor" attribute was introduced in SBML
   * Level 3.  It does not exist on Species in SBML Levels 1
   * and 2.
   */
  boolean isSetConversionFactor();
};

Species implements SBase;

[Prefix="libsbml::"]
interface Unit {
  long getScale();

  boolean isAmpere();
  boolean isAvogadro();
  boolean isBecquerel();
  boolean isCandela();
  boolean isCelsius();
  boolean isCoulomb();
  boolean isDimensionless();
  boolean isFarad();
  boolean isGram();
  boolean isGray();
  boolean isHenry();
  boolean isHertz();
  boolean isItem();
  boolean isJoule();
  boolean isKatal();
  boolean isKelvin();
  boolean isKilogram();
  boolean isLitre();
  boolean isLumen();
  boolean isLux();
  boolean isMetre();
  boolean isMole();
  boolean isNewton();
  boolean isOhm();
  boolean isPascal();
  boolean isRadian();
  boolean isSecond();
  boolean isSiemens();
  boolean isSievert();
  boolean isSteradian();
  boolean isTesla();
  boolean isVolt();
  boolean isWatt();
  boolean isWeber();
};

Unit implements SBase;

[Prefix="libsbml::"]
interface UnitDefinition {
  unsigned long getNumUnits();
  Unit createUnit();
  Unit getUnit(unsigned long n);
};

UnitDefinition implements SBase;

enum libsbml__idl__ASTNodeType_t {
    "libsbml::AST_PLUS"
  , "libsbml::AST_MINUS"
  , "libsbml::AST_TIMES"
  , "libsbml::AST_DIVIDE"
  , "libsbml::AST_POWER"

  , "libsbml::AST_INTEGER"
  , "libsbml::AST_REAL"
  , "libsbml::AST_REAL_E"
  , "libsbml::AST_RATIONAL"

  , "libsbml::AST_NAME"
  , "libsbml::AST_NAME_AVOGADRO"
  , "libsbml::AST_NAME_TIME"

  , "libsbml::AST_CONSTANT_E"
  , "libsbml::AST_CONSTANT_FALSE"
  , "libsbml::AST_CONSTANT_PI"
  , "libsbml::AST_CONSTANT_TRUE"

  , "libsbml::AST_LAMBDA"

  , "libsbml::AST_FUNCTION"
  , "libsbml::AST_FUNCTION_ABS"
  , "libsbml::AST_FUNCTION_ARCCOS"
  , "libsbml::AST_FUNCTION_ARCCOSH"
  , "libsbml::AST_FUNCTION_ARCCOT"
  , "libsbml::AST_FUNCTION_ARCCOTH"
  , "libsbml::AST_FUNCTION_ARCCSC"
  , "libsbml::AST_FUNCTION_ARCCSCH"
  , "libsbml::AST_FUNCTION_ARCSEC"
  , "libsbml::AST_FUNCTION_ARCSECH"
  , "libsbml::AST_FUNCTION_ARCSIN"
  , "libsbml::AST_FUNCTION_ARCSINH"
  , "libsbml::AST_FUNCTION_ARCTAN"
  , "libsbml::AST_FUNCTION_ARCTANH"
  , "libsbml::AST_FUNCTION_CEILING"
  , "libsbml::AST_FUNCTION_COS"
  , "libsbml::AST_FUNCTION_COSH"
  , "libsbml::AST_FUNCTION_COT"
  , "libsbml::AST_FUNCTION_COTH"
  , "libsbml::AST_FUNCTION_CSC"
  , "libsbml::AST_FUNCTION_CSCH"
  , "libsbml::AST_FUNCTION_DELAY"
  , "libsbml::AST_FUNCTION_EXP"
  , "libsbml::AST_FUNCTION_FACTORIAL"
  , "libsbml::AST_FUNCTION_FLOOR"
  , "libsbml::AST_FUNCTION_LN"
  , "libsbml::AST_FUNCTION_LOG"
  , "libsbml::AST_FUNCTION_PIECEWISE"
  , "libsbml::AST_FUNCTION_POWER"
  , "libsbml::AST_FUNCTION_ROOT"
  , "libsbml::AST_FUNCTION_SEC"
  , "libsbml::AST_FUNCTION_SECH"
  , "libsbml::AST_FUNCTION_SIN"
  , "libsbml::AST_FUNCTION_SINH"
  , "libsbml::AST_FUNCTION_TAN"
  , "libsbml::AST_FUNCTION_TANH"

  , "libsbml::AST_LOGICAL_AND"
  , "libsbml::AST_LOGICAL_NOT"
  , "libsbml::AST_LOGICAL_OR"
  , "libsbml::AST_LOGICAL_XOR"

  , "libsbml::AST_RELATIONAL_EQ"
  , "libsbml::AST_RELATIONAL_GEQ"
  , "libsbml::AST_RELATIONAL_GT"
  , "libsbml::AST_RELATIONAL_LEQ"
  , "libsbml::AST_RELATIONAL_LT"
  , "libsbml::AST_RELATIONAL_NEQ"

  /*, "libsbml::AST_QUALIFIER_BVAR"
  , "libsbml::AST_QUALIFIER_LOGBASE"
  , "libsbml::AST_QUALIFIER_DEGREE"

  , "libsbml::AST_SEMANTICS"

  , "libsbml::AST_CONSTRUCTOR_PIECE"
  , "libsbml::AST_CONSTRUCTOR_OTHERWISE"*/

  /*, "libsbml::AST_UNKNOWN"
  , "libsbml::AST_ORIGINATES_IN_PACKAGE"*/
  // TODO: add min/max based on libsbml version
};

[Prefix="libsbml::"]
interface ASTNode {
  long getNumChildren();
  ASTNode getChild(long i);

  libsbml__idl__ASTNodeType_t getType();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  ByteString getName();
  long setName(ByteString name);
};

[Prefix="libsbml::"]
interface Parameter {
  double getValue();
  long setValue(double value);
  boolean isSetValue();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();
};

Parameter implements SBase;

[Prefix="libsbml::"]
interface Delay {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface Priority {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface EventAssignment {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] DOMString getVariable();
    long setVariable(DOMString variable);
    boolean isSetVariable();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();
};

[Prefix="libsbml::"]
interface Trigger {
    DOMString getId();
    boolean setId(DOMString id);

    DOMString getName();
    long setName(DOMString name);
    boolean isSetName();

    [Const] ASTNode getMath();
    long setMath(ASTNode math);
    boolean isSetMath();

    boolean getPersistent();
    long setPersistent(boolean persistent);
    boolean isSetPersistent();
};

[Prefix="libsbml::"]
interface Event {
  DOMString getId();
  boolean setId(DOMString id);

  DOMString getName();
  long setName(DOMString name);
  boolean isSetName();

  Delay createDelay();
  Delay getDelay();
  long setDelay([Const] Delay delay);
  boolean isSetDelay();

  Priority createPriority();
  long setPriority(Priority priority);
  Priority getPriority();
  boolean isSetPriority();

  long setTrigger(Trigger trigger);
  Trigger getTrigger();
  boolean isSetTrigger();

  EventAssignment createEventAssignment();
  EventAssignment getEventAssignment(unsigned long n);
  unsigned long getNumEventAssignments();
};

[Prefix="libsbml::"]
interface FunctionDefinition {
  DOMString getId();
  boolean setId(DOMString id);

  DOMString getName();
  long setName(DOMString name);
  boolean isSetName();

  unsigned long getNumArguments();
  [Const] ASTNode getArgument(unsigned long n);

  [Const] ASTNode getBody();
  boolean isSetBody();

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();
};

[Prefix="libsbml::"]
interface LocalParameter {
  double getValue();
  long setValue(double value);
  boolean isSetValue();

  boolean isSetUnits();
  DOMString getUnits();
  long setUnits(DOMString units);

  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();
};

LocalParameter implements SBase;

[Prefix="libsbml::"]
interface KineticLaw {
  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  unsigned long getNumLocalParameters();
  LocalParameter createLocalParameter();
  LocalParameter getLocalParameter(unsigned long i);

  unsigned long getNumParameters();
  Parameter createParameter();
  Parameter getParameter(unsigned long i);

  DOMString getFormula();
  long setFormula(DOMString formula);
};

KineticLaw implements SBase;

[Prefix="libsbml::"]
interface SBMLFormulaParser {
  void SBMLFormulaParser();
  ASTNode parseL3Formula(DOMString formula);
  ASTNode parseFormula(DOMString formula);
};

[Prefix="libsbml::"]
interface Reaction {
  long getNumReactants();
  long getNumProducts();
  long getNumModifiers();

  SpeciesReference getReactant(long i);
  SpeciesReference getProduct(long i);
  ModifierSpeciesReference getModifier(long i);

  long addReactant(SpeciesReference sr);
  long addProduct(SpeciesReference sr);
  long addModifier(ModifierSpeciesReference sr);

  SpeciesReference createReactant();
  SpeciesReference createProduct();
  ModifierSpeciesReference createModifier();

  KineticLaw createKineticLaw();
  KineticLaw getKineticLaw();
  boolean isSetKineticLaw();

  boolean getReversible();
  long setReversible(boolean value);
  boolean isSetReversible();
};

Reaction implements SBase;

[Prefix="libsbml::"]
interface Compartment {
  boolean getConstant();
  long setConstant(boolean value);
  boolean isSetConstant();

  double getSize();
  long setSize(double val);
  boolean isSetSize();

  double getVolume();
  long setVolume(double val);
  boolean isSetVolume();

  DOMString getUnits();
  long setUnits(DOMString units);
  boolean isSetUnits();
};

Compartment implements SBase;

[Prefix="libsbml::"]
interface Rule {
  boolean isRate();
  boolean isAssignment();
  boolean isAlgebraic();

  DOMString getFormula();
  long setFormula(DOMString formula);

  boolean isParameter();
};

Rule implements SBase;

[Prefix="libsbml::"]
interface AssignmentRule {
  DOMString getVariable();
  long setVariable(DOMString id);
  boolean isSetVariable();

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  DOMString getFormula();
  long setFormula(DOMString formula);

  boolean isParameter();
};

AssignmentRule implements SBase;

[Prefix="libsbml::"]
interface RateRule {
  DOMString getFormula();
  long setFormula(DOMString formula);

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  boolean isParameter();
};

RateRule implements SBase;

[Prefix="libsbml::"]
interface AlgebraicRule {
  DOMString getFormula();
  long setFormula(DOMString formula);

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  boolean isParameter();
};

AlgebraicRule implements SBase;

[Prefix="libsbmljs::"]
interface RuleSwitch {
  void RuleSwitch();

  AssignmentRule castToAssignmentRule(Rule r);
  RateRule castToRateRule(Rule r);
  AlgebraicRule castToAlgebraicRule(Rule r);
};

[Prefix="libsbml::"]
interface Model {
  unsigned long getNumReactions();
  Reaction getReaction(unsigned long i);
  Reaction createReaction();

  unsigned long getNumSpecies();
  Species createSpecies();
  Species getSpecies(unsigned long i);
  Species removeSpecies(unsigned long i);

  unsigned long getNumUnitDefinitions();
  UnitDefinition getUnitDefinition(unsigned long i);
  UnitDefinition createUnitDefinition();

  unsigned long getNumCompartments();
  Compartment getCompartment(unsigned long i);
  Compartment createCompartment();

  unsigned long getNumParameters();
  Parameter createParameter();
  Parameter getParameter(unsigned long i);

  unsigned long getNumEvents();
  Event createEvent();
  Event getEvent(unsigned long i);

  unsigned long getNumFunctionDefinitions();
  FunctionDefinition createFunctionDefinition();
  FunctionDefinition getFunctionDefinition(unsigned long i);

  unsigned long getNumRules();
  Rule getRule(unsigned long i);

  unsigned long getNumPlugins();
  SBasePlugin getPlugin(unsigned long n);
//   SBasePlugin getPlugin(DOMString name);
};

Model implements SBase;

[Prefix="libsbml::"]
interface SBMLError {
  DOMString getMessage();
};

[Prefix="libsbml::"]
interface SBMLErrorLog {
// reserved word apparently. whoop-de-doo
//   DOMString toString();
};

[Prefix="libsbml::"]
interface SBasePlugin {
  // TODO: doc
  DOMString getPackageName();

  // TODO: doc
  DOMString getPrefix();

  // TODO: doc
  DOMString getURI();
  unsigned long getVersion();
  unsigned long getLevel();
};

enum libsbml__idl__SBMLErrorCategory_t {
  "libsbml::LIBSBML_CAT_SBML",
  "libsbml::LIBSBML_CAT_SBML_L1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L2V1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L2V2_COMPAT",
  "libsbml::LIBSBML_CAT_GENERAL_CONSISTENCY",
  "libsbml::LIBSBML_CAT_IDENTIFIER_CONSISTENCY",
  "libsbml::LIBSBML_CAT_UNITS_CONSISTENCY",
  "libsbml::LIBSBML_CAT_MATHML_CONSISTENCY",
  "libsbml::LIBSBML_CAT_SBO_CONSISTENCY",
  "libsbml::LIBSBML_CAT_OVERDETERMINED_MODEL",
  "libsbml::LIBSBML_CAT_SBML_L2V3_COMPAT",
  "libsbml::LIBSBML_CAT_MODELING_PRACTICE",
  "libsbml::LIBSBML_CAT_INTERNAL_CONSISTENCY",
  "libsbml::LIBSBML_CAT_SBML_L2V4_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L3V1_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_L3V2_COMPAT",
  "libsbml::LIBSBML_CAT_SBML_COMPATIBILITY"
};

[Prefix="libsbml::"]
interface SBMLDocument {
  // ctor
  void SBMLDocument(long level, long version);

  // model
  Model getModel();
  Model createModel();

  // errors
  unsigned long getNumErrors();
  [Const] SBMLError getError(unsigned long n);
  SBMLErrorLog getErrorLog();

  // level / version
  unsigned long getVersion();
  unsigned long getLevel();

  // plugins / packages
  unsigned long getNumPlugins();
  SBasePlugin getPlugin(unsigned long n);

  boolean enablePackage(DOMString pkgName, DOMString pkgPrefix, boolean flag);
  boolean disablePackage(DOMString pkgName, DOMString pkgPrefix);
  boolean isPackageEnabled(DOMString pkgName);
  long setPackageRequired(DOMString pkgName, boolean flag);

  // validation
  unsigned long checkConsistency();
  unsigned long checkInternalConsistency();
  unsigned long validateSBML();

  // compatibility checking
  unsigned long checkL1Compatibility();
  unsigned long checkL2v1Compatibility();
  unsigned long checkL2v2Compatibility();
  unsigned long checkL2v3Compatibility();
  unsigned long checkL2v4Compatibility();
  unsigned long checkL3v1Compatibility();
  unsigned long checkL3v2Compatibility();

  void setConsistencyChecks(libsbml__idl__SBMLErrorCategory_t category, boolean apply);
};

[Prefix="libsbml::"]
interface SBMLReader {
  void SBMLReader();
  SBMLDocument readSBMLFromString(DOMString sbmlstr);
};

// different name req'd b/c libsbml version did not have consistent usage of types
[Prefix="libsbml::"]
interface SBMLWriter {
  void SBMLWriter();
  // BUG in Emscripten: memory may not be freed
  ByteString writeSBMLToString(SBMLDocument doc);
};

[Prefix="libsbmljs::"]
interface Capabilities {
  void Capabilities();
  boolean isLayoutSupported();
  boolean isRenderSupported();
};
