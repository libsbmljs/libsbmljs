/**
 * # A delay on the time of execution of an SBML event.
 *
 * An Event object defines when the event can occur, the variables that
 * are affected by the event, and how the variables are affected.  The
 * effect of the event can optionally be delayed after the occurrence of
 * the condition which invokes it.  An event delay is defined using an
 * object of class Delay.
 *
 * The object class Delay is derived from SBase and adds a single
 * subelement called "math".  This subelement is used to hold MathML
 * content.  The mathematical formula represented by "math" must evaluate
 * to a numerical value.  It is used as the length of time between when the
 * event is triggered and when the event's assignments are
 * actually executed.  If no delay is present on a given Event, a time
 * delay of zero is assumed.
 *
 * The expression in "math" must be evaluated at the time the event is
 * triggered.  The expression must always evaluate to a nonnegative number
 * (otherwise, a nonsensical situation could arise where an event is
 * defined to execute before it is triggered!).
 *
 * ## The units of the mathematical expression in a Delay
 *
 * In SBML Level 2 versions before Version 4, the units of the
 * numerical value computed by the Delay's "math" expression are
 * required to be in units of time, or the model is considered to have a
 * unit consistency error.  In Level 2 Version 4 as well as SBML
 * Level 3, this requirement is relaxed; these
 * specifications only stipulate that the units of the numerical value
 * computed by a Delay instance's "math" expression should match the
 * model's units of time (meaning the definition of the time units in
 * the model).  LibSBML respects these requirements, and depending on
 * whether an earlier Version of SBML Level 2 is in use, libSBML may
 * or may not flag unit inconsistencies as errors or merely warnings.
 *
 * Note that units are not predefined or assumed for the contents
 * of "math" in a Delay object; rather, they must be defined explicitly for
 * each instance of a Delay object in a model.  This is an important point
 * to bear in mind when literal numbers are used in delay expressions.  For
 * example, the following Event instance would result in a warning logged
 * by SBMLDocument::checkConsistency() about the fact that libSBML cannot
 * verify the consistency of the units of the expression.  The reason is
 * that the formula inside the "math" element does not have any declared
 * units, whereas what is expected in this context is units of time:
 *
 * ```
 * <model>
 *     ...
 *     <listOfEvents>
 *         <event useValuesFromTriggerTime="true">
 *             ...
 *             <delay>
 *                 <math xmlns="http://www.w3.org/1998/Math/MathML">
 *                     <cn> 1 </cn>
 *                 </math>
 *             </delay>
 *             ...
 *         </event>
 *     </listOfEvents>
 *     ...
 * </model>
 * ```
 *
 * The `<cn> 1 </cn>` within the mathematical formula
 * of the delay above has no units declared.  To make the
 * expression have the needed units of time, literal numbers should be
 * avoided in favor of defining Parameter objects for each quantity, and
 * declaring units for the Parameter values.  The following fragment of
 * SBML illustrates this approach:
 *
 * ```
 * <model>
 *    ...
 *    <listOfParameters>
 *        <parameter id="transcriptionDelay" value="10" units="second"/>
 *    </listOfParameters>
 *    ...
 *    <listOfEvents>
 *        <event useValuesFromTriggerTime="true">
 *            ...
 *            <delay>
 *                <math xmlns="http://www.w3.org/1998/Math/MathML">
 *                    <ci> transcriptionDelay </ci>
 *                </math>
 *            </delay>
 *            ...
 *        </event>
 *    </listOfEvents>
 *    ...
 * </model>
 * ```
 *
 * In SBML Level 3, an alternative approach is available in the form
 * of the units attribute, which SBML Level 3 allows to appear on
 * MathML cn elements.  The value of this attribute can be used to
 * indicate the unit of measurement to be associated with the number in the
 * content of a cn element.  The attribute is named units but,
 * because it appears inside MathML element (which is in the XML namespace
 * for MathML and not the namespace for SBML), it must always be prefixed
 * with an XML namespace prefix for an SBML Level 3
 * namespace.  The following is an example of this approach:
 *
 * ```
 * <model timeUnits="second" ...>
 *    ...
 *    <listOfEvents>
 *        <event useValuesFromTriggerTime="true">
 *            ...
 *            <delay>
 *                <math xmlns="http://www.w3.org/1998/Math/MathML"
 *                      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core">
 *                    <cn sbml:units="second"> 10 </cn>
 *                </math>
 *            </delay>
 *            ...
 *        </event>
 *    </listOfEvents>
 *    ...
 * </model>
 * ```
 *
 * ## Restrictions relaxed in SBML Level 3 Version 2
 *
 * In SBML Level 3 Version 2, the requirement that a Delay
 * have a "math" subelement was relaxed, making it optional.  In
 * this case, the Delay remains undefined, and unless that information
 * is provided in some other form (such as with an SBML Level 3
 * package), the Event behaves as if it had no Delay.
 */
[Prefix="libsbml::"]
interface Delay {
  /**
   * Get the mathematical formula for the delay and return it
   * as an AST.
   *
   * @return {ASTNode} the math of this Delay, or NULL if the math is not set
   */
  [Const] ASTNode getMath();

  /**
   * Sets the delay expression of this Delay instance to a copy of the given
   * ASTNode.
   *
   * @param {ASTNode} math an ASTNode representing a formula tree
   */
  long setMath(ASTNode math);

  /**
   * Predicate to test whether the formula for this delay is set.
   *
   * @return {boolean} true if the formula (meaning the math subelement) of
   * this Delay is set, false otherwise
   */
  boolean isSetMath();
};

Delay implements SBase;

/**
 * # The priority of execution of an SBML event.
 *
 * The Priority object class (which was introduced in SBML Level 3
 * Version 1), like Delay, is derived from SBase and contains a MathML
 * formula stored in the element "math".  This formula is used to compute a
 * dimensionless numerical value that influences the order in which a
 * simulator is to perform the assignments of two or more events that
 * happen to be executed simultaneously.  The formula may evaluate to any
 * double value (and thus may be a positive or negative number, or
 * zero), with positive numbers taken to signifying a higher priority than
 * zero or negative numbers.  If no Priority object is present on a given
 * Event object, no priority is defined for that event.
 *
 * ## The interpretation of priorities on events in a model
 *
 * For the purposes of SBML, simultaneous event execution is
 * defined as the situation in which multiple events have identical
 * times of execution.  The time of execution is calculated as the
 * sum of the time at which a given event's Trigger is triggered
 * plus its Delay duration, if any.  Here, identical times means
 * mathematically equal instants in time.  (In practice,
 * simulation software adhering to this specification may have to
 * rely on numerical equality instead of strict mathematical
 * equality; robust models will ensure that this difference will not
 * cause significant discrepancies from expected behavior.)
 *
 * If no Priority subobjects are defined for two or more Event objects,
 * then those events are still executed simultaneously but their order of
 * execution is undefined by the SBML Level 3
 * specification.  A software implementation may choose to execute
 * such simultaneous events in any order, as long as each event is executed
 * only once and the requirements of checking the "persistent" attribute
 * (and acting accordingly) are satisfied.
 *
 * If Priority subobjects are defined for two or more
 * simultaneously-triggered events, the order in which those particular
 * events must be executed is dictated by their Priority objects,
 * as follows.  If the values calculated using the two Priority
 * objects' "math" expressions differ, then the event having
 * the higher priority value must be executed before the event with
 * the lower value.  If, instead, the two priority values are
 * mathematically equal, then the two events must be triggered in a
 * random order.  It is important to note that a random
 *   order is not the same as an undefined order: given multiple
 * runs of the same model with identical conditions, an undefined
 * ordering would permit a system to execute the events in (for
 * example) the same order every time (according to whatever scheme
 * may have been implemented by the system), whereas the explicit
 * requirement for random ordering means that the order of execution
 * in different simulation runs depends on random chance.  In other
 * words, given two events A and B, a randomly-determined
 * order must lead to an equal chance of executing A first or
 * B first, every time those two events are executed
 * simultaneously.
 *
 * A model may contain a mixture of events, some of which have
 * Priority subobjects and some do not.  Should a combination of
 * simultaneous events arise in which some events have priorities
 * defined and others do not, the set of events with defined
 * priorities must trigger in the order determined by their Priority
 * objects, and the set of events without Priority objects must be
 * executed in an undefined order with respect to each other
 * and with respect to the events with Priority subobjects.  (Note
 * that undefined order does not necessarily mean random
 * order, although a random ordering would be a valid implementation
 * of this requirement.)
 *
 * The following example may help further clarify these points.
 * Suppose a model contains four events that should be executed
 * simultaneously, with two of the events having Priority objects
 * with the same value and the other two events having Priority
 * objects with the same, but different, value.  The two events with
 * the higher priorities must be executed first, in a random order
 * with respect to each other, and the remaining two events must be
 * executed after them, again in a random order, for a total of four
 * possible and equally-likely event executions: A-B-C-D, A-B-D-C,
 * B-A-C-D, and B-A-D-C.  If, instead, the model contains four events
 * all having the same Priority values, there are 4! or 24
 * possible orderings, each of which must be equally likely to be
 * chosen.  Finally, if none of the four events has a Priority
 * subobject defined, or even if exactly one of the four events has a
 * defined Priority, there are again 24 possible orderings, but the
 * likelihood of choosing any particular ordering is undefined; the
 * simulator can choose between events as it wishes.  (The SBML
 * specification only defines the effects of priorities on Event
 * objects with respect to other Event objects with
 * priorities.  Putting a priority on a single Event object
 * in a model does not cause it to fall within that scope.)
 *
 * ## Evaluation of Priority expressions
 *
 * An event's Priority object "math" expression must be
 * evaluated at the time the Event is to be executed.  During
 * a simulation, all simultaneous events have their Priority values
 * calculated, and the event with the highest priority is selected for
 * next execution.  Note that it is possible for the execution of one
 * Event object to cause the Priority value of another
 * simultaneously-executing Event object to change (as well as to
 * trigger other events, as already noted).  Thus, after executing
 * one event, and checking whether any other events in the model have
 * been triggered, all remaining simultaneous events that
 * either (i) have Trigger objects with attributes
 * "persistent"=false or (ii) have Trigger
 * expressions that did not transition from true to
 * false, must have their Priority expression reevaluated.
 * The highest-priority remaining event must then be selected for
 * execution next.
 *
 * ## Units of Priority object's mathematical expressions
 *
 * The unit associated with the value of a Priority object's
 * "math" expression should be dimensionless.  This is
 * because the priority expression only serves to provide a relative
 * ordering between different events, and only has meaning with
 * respect to other Priority object expressions.  The value of
 * Priority objects is not comparable to any other kind of object in
 * an SBML model.
 *
 * **Note:** The Priority construct exists only in SBML Level 3; it cannot
 * be used in SBML Level 2 or Level 1 models.
 *
 * ## Restrictions relaxed in SBML Level 3 Version 2
 *
 * In SBML Level 3 Version 2, the requirement that a Priority
 * have a "math" subelement was relaxed, making it optional.  In
 * this case, the Priority remains undefined, and unless that information
 * is provided in some other form (such as with an SBML Level 3
 * package), the Event behaves as if it had no Priority.
 */
[Prefix="libsbml::"]
interface Priority {
  /**
   * Get the mathematical formula for the priority and return it
   * as an AST.
   *
   * @return {ASTNode} the math of this Priority, or NULL if the math is not set
   */
  [Const] ASTNode getMath();

  /**
   * Sets the math expression of this Priority instance to a copy of the given
   * ASTNode.
   *
   * @param {ASTNode} math an ASTNode representing a formula tree
   */
  long setMath(ASTNode math);

  /**
   * Predicate to test whether the formula for this delay is set.
   *
   * @return {boolean} true if the formula (meaning the math subelement) of
   * this Priority is set, false otherwise
   */
  boolean isSetMath();
};

Priority implements SBase;

[Prefix="libsbml::"]
interface EventAssignment {
  [Const] DOMString getVariable();
  long setVariable(DOMString variable);
  boolean isSetVariable();

  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();
};

EventAssignment implements SBase;

[Prefix="libsbml::"]
interface Trigger {
  [Const] ASTNode getMath();
  long setMath(ASTNode math);
  boolean isSetMath();

  boolean getPersistent();
  long setPersistent(boolean persistent);
  boolean isSetPersistent();
};

Trigger implements SBase;

[Prefix="libsbml::"]
interface Event {
  Delay createDelay();
  Delay getDelay();
  long setDelay([Const] Delay delay);
  boolean isSetDelay();

  Priority createPriority();
  long setPriority(Priority priority);
  Priority getPriority();
  boolean isSetPriority();

  long setTrigger(Trigger trigger);
  Trigger getTrigger();
  boolean isSetTrigger();

  EventAssignment createEventAssignment();
  EventAssignment getEventAssignment(unsigned long n);
  unsigned long getNumEventAssignments();
};

Event implements SBase;
