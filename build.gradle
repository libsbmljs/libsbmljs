import java.nio.file.Path
import java.nio.file.Paths

description = "Run libsbml as JavaScript in the browser"
version = "0.0.1"

// locate and set up Emscripten variables

ext.emscriptenDir = "$System.env.EMSCRIPTEN"
if ("${emscriptenDir}" == "null") {
  throw new GradleException('The EMSCRIPTEN environment variable is not set. Run "source /path/to/emsdk_env.sh".')
}

ext.webIDLBinderPath = Paths.get(project.rootDir.path,"emtools","webidl_binder.py").toString()
def webIDLBinder = new File(webIDLBinderPath)
if (!webIDLBinder.exists() || webIDLBinder.isDirectory()) {
  throw new GradleException('Expected to find WebIDL binder at emtools/webidl_binder.py, but it does not exist')
}

ext.jsDocumentationGeneratorPath = Paths.get(project.rootDir.path,"tools","js_documentation_generator.py").toString()
def jsDocumentationGenerator = new File(jsDocumentationGeneratorPath)
if (!jsDocumentationGenerator.exists() || jsDocumentationGenerator.isDirectory()) {
  throw new GradleException('Expected to find js_documentation_generator.py at tools/js_documentation_generator.py, but it does not exist')
}

ext.makeAstEnumPath = Paths.get(project.rootDir.path,"tools","make_ast_enum.py").toString()
def makeAstEnum = new File(makeAstEnumPath)
if (!makeAstEnum.exists() || makeAstEnum.isDirectory()) {
  throw new GradleException('Expected to find make_ast_enum.py at tools/make_ast_enum.py, but it does not exist')
}

ext.astHeaderPath = Paths.get("libsbml","src","sbml","math","ASTNodeType.h").toString()
def astHeader = new File(astHeaderPath)
if (!astHeader.exists() || astHeader.isDirectory()) {
  ext.astHeaderPath = Paths.get("libsbml","src","sbml","math","ASTTypes.h").toString()
  println astHeaderPath
  astHeader = new File(astHeaderPath)
  if (!astHeader.exists() || astHeader.isDirectory()) {
    throw new GradleException('Expected to find ASTNodeType.h in libsbml/src/sbml/math, but it does not exist')
  }
}

def emscriptenToolsPath = Paths.get(emscriptenDir,"tools").toString()
def emscriptenToolsDir = new File(emscriptenToolsPath)
if (!emscriptenToolsDir.exists() || !emscriptenToolsDir.isDirectory()) {
  throw new GradleException('Expected to find the Emscripten tools directory $EMSCRIPTEN/tools, but it does not exist')
}

ext.emconfigureCommand = Paths.get(emscriptenDir,"emconfigure").toString()
def emconfigureFile = new File(emconfigureCommand)
if (!emconfigureFile.exists() || emconfigureFile.isDirectory()) {
  throw new GradleException('Expected to find emconfigure script at $EMSCRIPTEN/emconfigure, but it does not exist')
}

ext.emmakeCommand = Paths.get(emscriptenDir,"emmake").toString()
def emmakeFile = new File(emconfigureCommand)
if (!emmakeFile.exists() || emmakeFile.isDirectory()) {
  throw new GradleException('Expected to find emmake script at $EMSCRIPTEN/emmake, but it does not exist')
}

ext.emccCommand = Paths.get(emscriptenDir,"emcc").toString()
def emccFile = new File(emccCommand)
if (!emccFile.exists() || emccFile.isDirectory()) {
  throw new GradleException('Expected to find emcc at $EMSCRIPTEN/emcc, but it does not exist')
}

ext.emccToolchainPath = Paths.get(emscriptenDir,"cmake","Modules","Platform","Emscripten.cmake").toString()
def emccToolchain = new File(emccToolchainPath)
if (!emccToolchain.exists() || emccToolchain.isDirectory()) {
  throw new GradleException('Expected to find Emscripten.cmake binder at $EMSCRIPTEN/cmake/Modules/Platform/Emscripten.cmake, but it does not exist')
}

ext.documentationJSScript = Paths.get(project.rootDir.path,"node_modules","documentation","bin","documentation.js").toString()
def documentationJSScriptFile = new File(documentationJSScript)

// additional build options
// TODO: auto-discover
ext.isExperimentalBranch = findProperty('isExperimentalBranch') || false
ext.withEmrun = findProperty('withEmrun') || false

// optional libsbml packages
ext.enableLayout = findProperty('enableLayout') || true
ext.enableRender = findProperty('enableRender') || true
ext.enableFBC = findProperty('enableFBC') || true
ext.enableMulti = findProperty('enableMulti') || false
ext.enableQual = findProperty('enableQual') || true
ext.enableComp = findProperty('enableComp') || true
ext.enableDistrib = findProperty('enableDistrib') || isExperimentalBranch
ext.enableDyn = findProperty('enableDyn') || isExperimentalBranch
ext.enableGroups = findProperty('enableGroups') || true
ext.enableArrays = findProperty('enableArrays') || isExperimentalBranch
ext.enableSpatial = findProperty('enableSpatial') || isExperimentalBranch

class ConcatFiles extends DefaultTask {
  def files = []

  @OutputFile
  File target

  @TaskAction
  void concat() {
    target.withWriter { writer ->
      files.each { f ->
        getProject().file(f).withReader { reader ->
            writer << reader << '\n'
        }
      }
    }
  }

  public ConcatFiles include(String... includes) {
    files.addAll(includes);
    return this;
  }

  public ConcatFiles include(Path... includes) {
    files.addAll(includes*.toString());
    return this;
  }
}


// ** Create IDL wrapper **


// generate ast enum
task generateAstEnum(type:Exec) {
  workingDir Paths.get("$buildDir","docs").toString()

  inputs.file(makeAstEnum.getAbsolutePath())

  commandLine 'python3', makeAstEnum.getAbsolutePath(), "--input", astHeader.getAbsolutePath(), "--output", 'ast_enum.idl'
}
generateAstEnum.doFirst {
  mkdir Paths.get("$buildDir","docs").toString()
}

// ** Merge IDL files

task combineIDL(type: ConcatFiles) {
  String idl_dir = Paths.get("interface","idl")
  String core_idl_dir = Paths.get(idl_dir,"core")
  include Paths.get(core_idl_dir, "module_header.idl")
  include Paths.get("$buildDir","docs","ast_enum.idl").toString()
  include Paths.get(core_idl_dir, "reader.idl")
  include Paths.get(core_idl_dir, "writer.idl")
  include Paths.get(core_idl_dir, "document.idl")
  include Paths.get(core_idl_dir, "document_plugin.idl")
  include Paths.get(core_idl_dir, "model.idl")
  include Paths.get(core_idl_dir, "species.idl")
  include Paths.get(core_idl_dir, "reaction.idl")
  include Paths.get(core_idl_dir, "compartment.idl")
  include Paths.get(core_idl_dir, "parameter.idl")
  include Paths.get(core_idl_dir, "unit.idl")
  include Paths.get(core_idl_dir, "ast.idl")
  include Paths.get(core_idl_dir, "function.idl")
  include Paths.get(core_idl_dir, "event.idl")
  include Paths.get(core_idl_dir, "rule.idl")
  include Paths.get(core_idl_dir, "initial_assignment.idl")
  include Paths.get(core_idl_dir, "constraint.idl")
  include Paths.get(core_idl_dir, "cvterm.idl")
  include Paths.get(core_idl_dir, "sbase.idl")
  include Paths.get(core_idl_dir, "operation_return_values.idl")
  include Paths.get(core_idl_dir, "core_interface.idl")
  if (enableLayout) {
    include Paths.get(idl_dir, "layout", "species_reference_role.idl")
    include Paths.get(idl_dir, "layout", "curve.idl")
    include Paths.get(idl_dir, "layout", "layout.idl")
    include Paths.get(idl_dir, "layout", "extension.idl")
  }
  if (enableRender) {
    include Paths.get(idl_dir, "render", "render_interface.idl")
  }
  if (enableFBC) {
    include Paths.get(idl_dir, "fbc", "fluxbound.idl")
    include Paths.get(idl_dir, "fbc", "objective.idl")
    include Paths.get(idl_dir, "fbc", "flux_objective.idl")
    include Paths.get(idl_dir, "fbc", "fbc_and.idl")
    include Paths.get(idl_dir, "fbc", "fbc_or.idl")
    include Paths.get(idl_dir, "fbc", "fbc_association.idl")
    include Paths.get(idl_dir, "fbc", "geneproduct.idl")
    include Paths.get(idl_dir, "fbc", "gene_product_association.idl")
    include Paths.get(idl_dir, "fbc", "gene_product_ref.idl")
    include Paths.get(idl_dir, "fbc", "species_plugin.idl")
    include Paths.get(idl_dir, "fbc", "reaction_plugin.idl")
    include Paths.get(idl_dir, "fbc", "model_plugin.idl")
    include Paths.get(idl_dir, "fbc", "extension.idl")
  }
  if (enableGroups) {
    include Paths.get(idl_dir, "groups", "group.idl")
    include Paths.get(idl_dir, "groups", "group_kind.idl")
    include Paths.get(idl_dir, "groups", "member.idl")
    include Paths.get(idl_dir, "groups", "model_plugin.idl")
    include Paths.get(idl_dir, "groups", "document_plugin.idl")
    include Paths.get(idl_dir, "groups", "extension.idl")
  }
  if (enableMulti) {
  }
  if (enableQual) {
    include Paths.get(idl_dir, "qual", "default_term.idl")
    include Paths.get(idl_dir, "qual", "function_term.idl")
    include Paths.get(idl_dir, "qual", "input.idl")
    include Paths.get(idl_dir, "qual", "output.idl")
    include Paths.get(idl_dir, "qual", "qualitative_species.idl")
    include Paths.get(idl_dir, "qual", "transition.idl")
    include Paths.get(idl_dir, "qual", "model_plugin.idl")
    include Paths.get(idl_dir, "qual", "document_plugin.idl")
    include Paths.get(idl_dir, "qual", "extension.idl")
  }
  if (enableComp) {
    include Paths.get(idl_dir, "comp", "comp_base.idl")
    include Paths.get(idl_dir, "comp", "sbase_ref.idl")
    include Paths.get(idl_dir, "comp", "port.idl")
    include Paths.get(idl_dir, "comp", "model_definition.idl")
    include Paths.get(idl_dir, "comp", "external_model_definition.idl")
    include Paths.get(idl_dir, "comp", "submodel.idl")
    include Paths.get(idl_dir, "comp", "deletion.idl")
    include Paths.get(idl_dir, "comp", "replaced_element.idl")
    include Paths.get(idl_dir, "comp", "replaced_by.idl")
    include Paths.get(idl_dir, "comp", "replacing.idl")
    include Paths.get(idl_dir, "comp", "model_plugin.idl")
    include Paths.get(idl_dir, "comp", "sbase_plugin.idl")
    include Paths.get(idl_dir, "comp", "document_plugin.idl")
    include Paths.get(idl_dir, "comp", "extension.idl")
  }
  target = file(Paths.get("$buildDir","interface","idl","sbml_interface.idl"))
}
combineIDL.dependsOn(generateAstEnum)

task combineCPP(type: ConcatFiles) {
  String cpp_dir = Paths.get("interface","cpp")
  include Paths.get(cpp_dir, "common.cpp")
  include Paths.get(cpp_dir, "core_interface_wrapper.cpp")
  if (enableLayout) {
    include Paths.get(cpp_dir, "layout_interface_wrapper.cpp")
  }
  if (enableRender) {
    include Paths.get(cpp_dir, "render_interface_wrapper.cpp")
  }
  if (enableFBC) {
    include Paths.get(cpp_dir, "fbc_interface_wrapper.cpp")
  }
  if (enableGroups) {
    include Paths.get(cpp_dir, "groups_interface_wrapper.cpp")
  }
  if (enableMulti) {
  }
  if (enableQual) {
    include Paths.get(cpp_dir, "qual_interface_wrapper.cpp")
  }
  if (enableComp) {
    include Paths.get(cpp_dir, "comp_interface_wrapper.cpp")
  }
  include Paths.get(cpp_dir, "sbml_interface_proxy.cpp")
  target = file(Paths.get("$buildDir","interface","cpp","sbml_interface_wrapper.cpp"))
}

task patchLibSBML {
  ant.patch(patchfile: file('disable_compile_check.patch'),
            originalFile: Paths.get("libsbml","src","CMakeLists.txt"))
}

task generateIdlInterface(type:Exec) {
  workingDir Paths.get("$buildDir","interface","idl").toString()

  inputs.file(webIDLBinder.getAbsolutePath())

  environment 'PYTHONPATH', emscriptenDir

  commandLine 'python3', webIDLBinder.getAbsolutePath(), 'sbml_interface.idl', 'sbml_interface'
}
generateIdlInterface.dependsOn(combineIDL)

// validate expat and libsbml source directories

// expat
ext.expatPath = 'expat'
def expatDir = new File(expatPath)
if (!expatDir.exists() || !expatDir.isDirectory()) {
  throw new GradleException('Expected to find the directory "expat", but it does not exist')
}

def expatCMakeFile = new File(Paths.get(expatPath,"CMakeLists.txt").toString())
if (!expatCMakeFile.exists() || expatCMakeFile.isDirectory()) {
  throw new GradleException('Expected to find the file "expat/CMakeLists.txt", but it does not exist')
}
String expatCMakeSrc = expatCMakeFile.text
def expatVersionMatcher = (expatCMakeSrc =~ /(?m)^set\(PACKAGE_VERSION "([\d.]+)"\)$/)
if (expatVersionMatcher.getCount() == 1) {
  ext.expatVersion = expatVersionMatcher[0][1]
} else {
  throw new GradleException('Unable to determine expat version')
}

// libsbml
ext.libsbmlPath = 'libsbml'
def libsbmlDir = new File(libsbmlPath)
if (!libsbmlDir.exists() || !libsbmlDir.isDirectory()) {
  throw new GradleException('Expected to find the directory "libsbml", but it does not exist')
}

def sbmlTypesH = new File(Paths.get("libsbml","src","sbml","SBMLTypes.h").toString())
if (!sbmlTypesH.exists() || sbmlTypesH.isDirectory()) {
  throw new GradleException('Your libsbml/src/sbml source directory was expected to contain SBMLTypes.h, but it does not')
}

def sbmlVersionFile = new File(Paths.get("libsbml","VERSION.txt").toString())
if (!sbmlVersionFile.exists() || sbmlVersionFile.isDirectory()) {
  throw new GradleException('Your libsbml source directory was expected to contain VERSION.txt, but it does not')
}
ext.libSbmlVersion = sbmlVersionFile.text.trim()


// ** Build Expat **

// https://github.com/awrichar/gradle-external-build/blob/master/examples/cmake/build.gradle
// def getIntermediateDir = { binary ->
//     file("${buildDir}/external-build/${binary.component.name}")
// }
// def getInstallDir = { binary ->
//     file("${buildDir}/install/${binary.component.name}")
// }

// model {
//   // components {
//     expat(ExternalNativeLibrarySpec) {
//       buildConfig(CMake) {
//         def intDir = getIntermediateDir(binary)
//         def outputDir = getInstallDir(binary)
//
//         // Uncomment for easier debugging
//         redirectOutput = false
//
//         cmakeRoot expatPath
//         cmakeArgs "-DCMAKE_TOOLCHAIN_FILE=${emccToolchain} -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=${outputDir}"
//         targets 'install'
//
//         inputs.dir 'src'
//         inputs.file 'CMakeLists.txt'
//         outputs.dir outputDir
//
//         workingDir intDir
//         // environment = [
//         //     'PATH': toolChainPath,
//         // ]
//       }
//
//       buildOutput {
//         def outputDir = getInstallDir(binary)
//         outputFile = file("${outputDir}/lib/libexpat.so")
//       }
//     }
//   // }
// }

ext.cmakeCommand = 'cmake'

def expatOutputDir = Paths.get("${buildDir}","install","expat").toString()
task expatGenerate(type:Exec) {
  workingDir Paths.get("${buildDir}","build","expat").toString()
  // the award for most obtuse language goes to groovy
  def cmdlineArgs = ["${emconfigureCommand}","${cmakeCommand}",
    "-DCMAKE_TOOLCHAIN_FILE=${emccToolchain}",
    "-DCMAKE_BUILD_TYPE=Release",
    "-DCMAKE_INSTALL_PREFIX=${expatOutputDir}",
    "-DBUILD_shared=FALSE",
    "-DBUILD_doc=FALSE",
    Paths.get(project.rootDir.path,'expat').toString()] as String[]
  commandLine cmdlineArgs
}
expatGenerate.doFirst {
  mkdir Paths.get("${buildDir}","install","expat").toString()
  mkdir Paths.get("${buildDir}","build","expat").toString()
}
task expatBuild(type:Exec) {
  workingDir Paths.get("${buildDir}","build","expat").toString()
  def cmdlineArgs = ["${emmakeCommand}","${cmakeCommand}", "--build", ".", "--target", "install", "--config", "Release"] as String[]
  commandLine cmdlineArgs
}
expatBuild.dependsOn(expatGenerate)

def libsbmlOutputDir = Paths.get("${buildDir}","install","libsbml").toString()
task libsbmlGenerate(type:Exec) {
  workingDir Paths.get("${buildDir}","build","libsbml").toString()
  // the award for most obtuse language goes to groovy
  def cmdlineArgs = ["${emconfigureCommand}","${cmakeCommand}",
    "-DCMAKE_TOOLCHAIN_FILE=${emccToolchain}",
    "-DCMAKE_BUILD_TYPE=Release",
    "-DCMAKE_INSTALL_PREFIX=${libsbmlOutputDir}",
    "-DWITH_CPP_NAMESPACE=ON",
    "-DWITH_EXPAT=ON",
    "-DWITH_LIBXML=OFF",
    "-DENABLE_ARRAYS=${enableArrays}",
    "-DENABLE_COMP=${enableComp}",
    "-DENABLE_DISTRIB=${enableDistrib}",
    "-DENABLE_DYN=${enableDyn}",
    "-DENABLE_FBC=${enableFBC}",
    "-DENABLE_GROUPS=${enableGroups}",
    "-DENABLE_LAYOUT=${enableLayout}",
    "-DENABLE_MULTI=${enableMulti}",
    "-DENABLE_QUAL=${enableQual}",
    "-DENABLE_RENDER=${enableRender}",
    "-DENABLE_REQUIREDELEMENTS=ON",
    "-DENABLE_SPATIAL=${enableSpatial}",
    "-DEXPAT_PATH=${expatOutputDir}",
    "-DLIBEXPAT_INCLUDE_DIR="+Paths.get("${buildDir}","install","expat","include").toString(),
    "-DLIBEXPAT_LIBRARY="+Paths.get("${buildDir}","install","expat","lib","libexpat.a").toString(),
    Paths.get(project.rootDir.path,'libsbml').toString()] as String[]
  commandLine cmdlineArgs
}
libsbmlGenerate.doFirst {
  mkdir Paths.get("${buildDir}","install","libsbml").toString()
  mkdir Paths.get("${buildDir}","build","libsbml").toString()
}
libsbmlGenerate.dependsOn(patchLibSBML)
task libsbmlBuild(type:Exec) {
  workingDir Paths.get("${buildDir}","build","libsbml").toString()
  def cmdlineArgs = ["${emmakeCommand}","${cmakeCommand}", "--build", ".", "--target", "install", "--config", "Release"] as String[]
  commandLine cmdlineArgs
}
libsbmlBuild.dependsOn(libsbmlGenerate)


task emccCompileLibSBML(type:Exec) {
  workingDir "${buildDir}"
  def cmdlineArgs = ["${emccCommand}",
    "-O0",
    "-I",Paths.get(libsbmlOutputDir,"include").toString(),
    "-I",Paths.get(expatOutputDir,"include").toString(),
    "-I",Paths.get("$buildDir","interface","idl").toString(),
    "-std=c++11",
    combineCPP.target,
    Paths.get(libsbmlOutputDir,"lib","libsbml.so").toString(),
    "--post-js",Paths.get("$buildDir","interface","idl","sbml_interface.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","xhr.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","sbase.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","doc_getset.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","plugin_layout.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","plugin_render.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","model_getset.js"),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","astnode_getset.js"),
    "--post-js", Paths.get(project.rootDir.path,"interface","js","reaction_getset.js").toString(),
    "--post-js", Paths.get(project.rootDir.path,"interface","js","spec_ref_getset.js").toString(),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","modifier_spec_ref_getset.js").toString(),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","rules_getset.js").toString(),
    "--post-js",Paths.get(project.rootDir.path,"interface","js","export.js"),
    "-s","DISABLE_EXCEPTION_CATCHING=0",
    "-s","WASM=1",
    "-s","BINARYEN_METHOD='native-wasm'",
    "-s","BINARYEN_TRAP_MODE='clamp'",
    "-s","MODULARIZE=1",
    "-s","EXPORT_NAME=\"libsbml\"",
    "-s","ALLOW_MEMORY_GROWTH=1",
    // "-s","FILESYSTEM=0",
    // "-g",
    "-o","libsbml.js",
    ] as String[]
  if (withEmrun) {
    cmdlineArgs += ["--emrun"]
  }
  commandLine cmdlineArgs
}
emccCompileLibSBML.dependsOn(libsbmlBuild).dependsOn(combineCPP)
emccCompileLibSBML.dependsOn(libsbmlBuild).dependsOn(generateIdlInterface)


// // combine idl documentation
// task combineDoc(type: ConcatFiles) {
//   include Paths.get("$buildDir","docs","ast_enum.idl").toString()
//   include Paths.get("$buildDir","interface","idl","sbml_interface.idl").toString()
//   target = file(Paths.get("$buildDir","docs","merged.idl"))
// }
// combineDoc.dependsOn(combineCPP)
// combineDoc.dependsOn(combineIDL)
// // combineDoc.dependsOn(generateIdlInterface)
// combineDoc.dependsOn(generateAstEnum)


// generate docstrings
task generateDocstrings(type:Exec) {
  workingDir Paths.get("$buildDir","docs").toString()

  inputs.file(jsDocumentationGenerator.getAbsolutePath())

  environment 'PYTHONPATH', [emscriptenDir, Paths.get(emscriptenDir, "third_party"), Paths.get(emscriptenDir, "third_party", "ply")].join(":")

  commandLine 'python3', jsDocumentationGenerator.getAbsolutePath(), "--input", Paths.get("$buildDir","interface","idl","sbml_interface.idl").toString(), "--output", "docstrings.js"
}
generateDocstrings.dependsOn(combineIDL)
// generateDocstrings.dependsOn(combineDoc)


// combine all js docstrings
task combineDocstrings(type: ConcatFiles) {
  include Paths.get("$buildDir","docs","docstrings.js").toString()
  include Paths.get("docs","interface_extra_docs.js").toString()
  target = file(Paths.get("$buildDir","docs","merged_docstrings.js"))
}
combineDocstrings.dependsOn(generateDocstrings)


task generateDocumentation(type:Exec) {
  if (!documentationJSScriptFile.exists() || documentationJSScriptFile.isDirectory()) {
    throw new GradleException('Expected to find documentation.js at node_modules/documentation/bin/documentation.js, but it does not exist')
  }
  workingDir "${buildDir}"
  def cmdlineArgs = ["node",
    "${documentationJSScript}",
    "build",Paths.get("$buildDir","docs","merged_docstrings.js").toString(),
    "--project-name","libsbml.js",
    "--project-version","${libSbmlVersion}",
    "--project-description","WebAssembly/JavaScript bindings for libSBML",
    "--project-homepage","https://ww.github.io/libsbml.js/libsbml.js",
    "--shallow",
    "--format","html",
    "--output",Paths.get("$buildDir","docs","apidoc"),
    ] as String[]
  commandLine cmdlineArgs
}
generateDocumentation.dependsOn(combineDocstrings)

// TODO: glob files
task combineTests(type: ConcatFiles) {
  String tests_dir = Paths.get("karma","tests")
  include Paths.get(tests_dir, "header.js")
  include Paths.get(tests_dir, "reading.js")
  include Paths.get(tests_dir, "writing.js")
  include Paths.get(tests_dir, "units.js")
  include Paths.get(tests_dir, "layout.js")
  include Paths.get(tests_dir, "fbc.js")
  include Paths.get(tests_dir, "comp1.js")
  include Paths.get(tests_dir, "comp2.js")
  include Paths.get(tests_dir, "comp3.js")
  include Paths.get(tests_dir, "comp4.js")
  include Paths.get(tests_dir, "groups1.js")
  include Paths.get(tests_dir, "groups2.js")
  target = file(Paths.get("$buildDir","tests","index.js"))
}
combineTests.doFirst {
  mkdir Paths.get("$buildDir","tests").toString()
}


// print configured settings
println "libsbml.js build configuration"
println " -- expat version $expatVersion"
println " -- libsbml version $libSbmlVersion"
println "    SBML Packages:"
println "    -- Arrays ${enableArrays}"
println "    -- Comp ${enableComp}"
println "    -- Distrib ${enableDistrib}"
println "    -- Dyn ${enableDyn}"
println "    -- FBC ${enableFBC}"
println "    -- Groups ${enableGroups}"
println "    -- Layout ${enableLayout}"
println "    -- Multi ${enableMulti}"
println "    -- Qual ${enableQual}"
println "    -- Render ${enableRender}"
println "    -- Spatial ${enableSpatial}"
